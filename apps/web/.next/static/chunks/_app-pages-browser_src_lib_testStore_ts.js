"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_testStore_ts"],{

/***/ "(app-pages-browser)/./src/lib/testStore.ts":
/*!******************************!*\
  !*** ./src/lib/testStore.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addChoice: function() { return /* binding */ addChoice; },\n/* harmony export */   addQuestion: function() { return /* binding */ addQuestion; },\n/* harmony export */   addQuiz: function() { return /* binding */ addQuiz; },\n/* harmony export */   addTestAnnouncement: function() { return /* binding */ addTestAnnouncement; },\n/* harmony export */   addTestAssignment: function() { return /* binding */ addTestAssignment; },\n/* harmony export */   addTestCourse: function() { return /* binding */ addTestCourse; },\n/* harmony export */   addTestEnrollment: function() { return /* binding */ addTestEnrollment; },\n/* harmony export */   addTestFile: function() { return /* binding */ addTestFile; },\n/* harmony export */   addTestLesson: function() { return /* binding */ addTestLesson; },\n/* harmony export */   addTestMessage: function() { return /* binding */ addTestMessage; },\n/* harmony export */   addTestModule: function() { return /* binding */ addTestModule; },\n/* harmony export */   addTestNotification: function() { return /* binding */ addTestNotification; },\n/* harmony export */   addTestParentLink: function() { return /* binding */ addTestParentLink; },\n/* harmony export */   addTestSubmission: function() { return /* binding */ addTestSubmission; },\n/* harmony export */   countUnreadForThread: function() { return /* binding */ countUnreadForThread; },\n/* harmony export */   createTestThread: function() { return /* binding */ createTestThread; },\n/* harmony export */   deleteQuiz: function() { return /* binding */ deleteQuiz; },\n/* harmony export */   deleteTestAnnouncement: function() { return /* binding */ deleteTestAnnouncement; },\n/* harmony export */   deleteTestAssignment: function() { return /* binding */ deleteTestAssignment; },\n/* harmony export */   deleteTestCourse: function() { return /* binding */ deleteTestCourse; },\n/* harmony export */   deleteTestModule: function() { return /* binding */ deleteTestModule; },\n/* harmony export */   getAttemptForStudent: function() { return /* binding */ getAttemptForStudent; },\n/* harmony export */   getTestCourse: function() { return /* binding */ getTestCourse; },\n/* harmony export */   getTestFile: function() { return /* binding */ getTestFile; },\n/* harmony export */   getTestNotificationPreferences: function() { return /* binding */ getTestNotificationPreferences; },\n/* harmony export */   getTestProfile: function() { return /* binding */ getTestProfile; },\n/* harmony export */   gradeTestSubmission: function() { return /* binding */ gradeTestSubmission; },\n/* harmony export */   listAttemptsForQuiz: function() { return /* binding */ listAttemptsForQuiz; },\n/* harmony export */   listChoicesByQuestion: function() { return /* binding */ listChoicesByQuestion; },\n/* harmony export */   listQuestionsByQuiz: function() { return /* binding */ listQuestionsByQuiz; },\n/* harmony export */   listQuizzesByCourse: function() { return /* binding */ listQuizzesByCourse; },\n/* harmony export */   listTestAnnouncementsByCourse: function() { return /* binding */ listTestAnnouncementsByCourse; },\n/* harmony export */   listTestAssignmentsByCourse: function() { return /* binding */ listTestAssignmentsByCourse; },\n/* harmony export */   listTestCoursesByTeacher: function() { return /* binding */ listTestCoursesByTeacher; },\n/* harmony export */   listTestEnrollmentsByCourse: function() { return /* binding */ listTestEnrollmentsByCourse; },\n/* harmony export */   listTestEnrollmentsByStudent: function() { return /* binding */ listTestEnrollmentsByStudent; },\n/* harmony export */   listTestFeatureFlags: function() { return /* binding */ listTestFeatureFlags; },\n/* harmony export */   listTestLessonsByCourse: function() { return /* binding */ listTestLessonsByCourse; },\n/* harmony export */   listTestMessagesByThread: function() { return /* binding */ listTestMessagesByThread; },\n/* harmony export */   listTestModulesByCourse: function() { return /* binding */ listTestModulesByCourse; },\n/* harmony export */   listTestNotificationsByUser: function() { return /* binding */ listTestNotificationsByUser; },\n/* harmony export */   listTestParentChildren: function() { return /* binding */ listTestParentChildren; },\n/* harmony export */   listTestParentsForStudent: function() { return /* binding */ listTestParentsForStudent; },\n/* harmony export */   listTestParticipantsByThread: function() { return /* binding */ listTestParticipantsByThread; },\n/* harmony export */   listTestSubmissionsByAssignment: function() { return /* binding */ listTestSubmissionsByAssignment; },\n/* harmony export */   listTestThreadsByUser: function() { return /* binding */ listTestThreadsByUser; },\n/* harmony export */   markAllTestNotificationsRead: function() { return /* binding */ markAllTestNotificationsRead; },\n/* harmony export */   markAllThreadMessagesReadForUser: function() { return /* binding */ markAllThreadMessagesReadForUser; },\n/* harmony export */   markTestMessageReadForUser: function() { return /* binding */ markTestMessageReadForUser; },\n/* harmony export */   markTestNotificationRead: function() { return /* binding */ markTestNotificationRead; },\n/* harmony export */   removeTestParentLink: function() { return /* binding */ removeTestParentLink; },\n/* harmony export */   reorderTestLessons: function() { return /* binding */ reorderTestLessons; },\n/* harmony export */   resetTestStore: function() { return /* binding */ resetTestStore; },\n/* harmony export */   setTestFeatureFlag: function() { return /* binding */ setTestFeatureFlag; },\n/* harmony export */   setTestNotificationPreferences: function() { return /* binding */ setTestNotificationPreferences; },\n/* harmony export */   shouldDeliverTestNotification: function() { return /* binding */ shouldDeliverTestNotification; },\n/* harmony export */   startAttempt: function() { return /* binding */ startAttempt; },\n/* harmony export */   submitAttempt: function() { return /* binding */ submitAttempt; },\n/* harmony export */   updateQuiz: function() { return /* binding */ updateQuiz; },\n/* harmony export */   updateTestAssignment: function() { return /* binding */ updateTestAssignment; },\n/* harmony export */   updateTestModule: function() { return /* binding */ updateTestModule; },\n/* harmony export */   upsertAnswer: function() { return /* binding */ upsertAnswer; },\n/* harmony export */   upsertTestProfile: function() { return /* binding */ upsertTestProfile; }\n/* harmony export */ });\n/**\r\n * In-memory test store (dev/test only)\r\n *\r\n * Provides a lightweight, process-local data store used when `TEST_MODE`\r\n * is enabled. It simulates database behavior for e2e and unit tests, and\r\n * persists across Next.js HMR by attaching to `globalThis`.\r\n */ // Persist state across Next.js dev HMR by attaching to globalThis\nconst globalStore = globalThis;\nconst state = globalStore.__TEST_STORE__ || (globalStore.__TEST_STORE__ = {\n    courses: new Map(),\n    lessonsByCourse: new Map(),\n    modulesByCourse: new Map(),\n    enrollmentsByStudent: new Map(),\n    enrollmentsByCourse: new Map(),\n    profilesById: new Map(),\n    parentLinksByParent: new Map()\n});\n// Backfill maps if this module loaded after an older store shape was created (HMR during dev)\nconst anyState = state;\nif (!anyState.profilesById) anyState.profilesById = new Map();\nif (!anyState.parentLinksByParent) anyState.parentLinksByParent = new Map();\nif (!anyState.modulesByCourse) anyState.modulesByCourse = new Map();\nif (!anyState.assignmentsByCourse) anyState.assignmentsByCourse = new Map();\nif (!anyState.submissionsByAssignment) anyState.submissionsByAssignment = new Map();\n// Quizzes store maps (backfill if missing for HMR)\nif (!anyState.quizzesByCourse) anyState.quizzesByCourse = new Map();\nif (!anyState.questionsByQuiz) anyState.questionsByQuiz = new Map();\nif (!anyState.choicesByQuestion) anyState.choicesByQuestion = new Map();\nif (!anyState.attemptsByQuiz) anyState.attemptsByQuiz = new Map();\nif (!anyState.answersByAttempt) anyState.answersByAttempt = new Map();\nif (!anyState.announcementsByCourse) anyState.announcementsByCourse = new Map();\nif (!anyState.filesById) anyState.filesById = new Map();\n// Messaging maps\nif (!anyState.messageThreads) anyState.messageThreads = [];\nif (!anyState.participantsByThread) anyState.participantsByThread = new Map();\nif (!anyState.messagesByThread) anyState.messagesByThread = new Map();\nif (!anyState.readByMessage) anyState.readByMessage = new Map();\nif (!anyState.featureFlags) anyState.featureFlags = new Map();\nfunction addTestCourse(course) {\n    state.courses.set(course.id, course);\n}\nfunction getTestCourse(courseId) {\n    return state.courses.get(courseId);\n}\nfunction listTestCoursesByTeacher(teacherId) {\n    return Array.from(state.courses.values()).filter((c)=>c.teacher_id === teacherId);\n}\nfunction addTestLesson(lesson) {\n    var _state_lessonsByCourse_get;\n    const arr = (_state_lessonsByCourse_get = state.lessonsByCourse.get(lesson.course_id)) !== null && _state_lessonsByCourse_get !== void 0 ? _state_lessonsByCourse_get : [];\n    arr.push(lesson);\n    arr.sort((a, b)=>a.order_index - b.order_index);\n    state.lessonsByCourse.set(lesson.course_id, arr);\n}\nfunction listTestLessonsByCourse(courseId) {\n    var _state_lessonsByCourse_get;\n    return (_state_lessonsByCourse_get = state.lessonsByCourse.get(courseId)) !== null && _state_lessonsByCourse_get !== void 0 ? _state_lessonsByCourse_get : [];\n}\nfunction resetTestStore() {\n    var _state_assignmentsByCourse_clear, _state_assignmentsByCourse, _state_submissionsByAssignment_clear, _state_submissionsByAssignment, _state_quizzesByCourse_clear, _state_quizzesByCourse, _state_questionsByQuiz_clear, _state_questionsByQuiz, _state_choicesByQuestion_clear, _state_choicesByQuestion, _state_attemptsByQuiz_clear, _state_attemptsByQuiz, _state_answersByAttempt_clear, _state_answersByAttempt, _state_announcementsByCourse_clear, _state_announcementsByCourse, _state_participantsByThread_clear, _state_participantsByThread, _state_messagesByThread_clear, _state_messagesByThread, _state_filesById_clear, _state_filesById;\n    state.courses.clear();\n    state.lessonsByCourse.clear();\n    state.modulesByCourse.clear();\n    state.enrollmentsByStudent.clear();\n    state.enrollmentsByCourse.clear();\n    state.parentLinksByParent.clear();\n    (_state_assignmentsByCourse = state.assignmentsByCourse) === null || _state_assignmentsByCourse === void 0 ? void 0 : (_state_assignmentsByCourse_clear = _state_assignmentsByCourse.clear) === null || _state_assignmentsByCourse_clear === void 0 ? void 0 : _state_assignmentsByCourse_clear.call(_state_assignmentsByCourse);\n    (_state_submissionsByAssignment = state.submissionsByAssignment) === null || _state_submissionsByAssignment === void 0 ? void 0 : (_state_submissionsByAssignment_clear = _state_submissionsByAssignment.clear) === null || _state_submissionsByAssignment_clear === void 0 ? void 0 : _state_submissionsByAssignment_clear.call(_state_submissionsByAssignment);\n    (_state_quizzesByCourse = // Quizzes\n    state.quizzesByCourse) === null || _state_quizzesByCourse === void 0 ? void 0 : (_state_quizzesByCourse_clear = _state_quizzesByCourse.clear) === null || _state_quizzesByCourse_clear === void 0 ? void 0 : _state_quizzesByCourse_clear.call(_state_quizzesByCourse);\n    (_state_questionsByQuiz = state.questionsByQuiz) === null || _state_questionsByQuiz === void 0 ? void 0 : (_state_questionsByQuiz_clear = _state_questionsByQuiz.clear) === null || _state_questionsByQuiz_clear === void 0 ? void 0 : _state_questionsByQuiz_clear.call(_state_questionsByQuiz);\n    (_state_choicesByQuestion = state.choicesByQuestion) === null || _state_choicesByQuestion === void 0 ? void 0 : (_state_choicesByQuestion_clear = _state_choicesByQuestion.clear) === null || _state_choicesByQuestion_clear === void 0 ? void 0 : _state_choicesByQuestion_clear.call(_state_choicesByQuestion);\n    (_state_attemptsByQuiz = state.attemptsByQuiz) === null || _state_attemptsByQuiz === void 0 ? void 0 : (_state_attemptsByQuiz_clear = _state_attemptsByQuiz.clear) === null || _state_attemptsByQuiz_clear === void 0 ? void 0 : _state_attemptsByQuiz_clear.call(_state_attemptsByQuiz);\n    (_state_answersByAttempt = state.answersByAttempt) === null || _state_answersByAttempt === void 0 ? void 0 : (_state_answersByAttempt_clear = _state_answersByAttempt.clear) === null || _state_answersByAttempt_clear === void 0 ? void 0 : _state_answersByAttempt_clear.call(_state_answersByAttempt);\n    (_state_announcementsByCourse = state.announcementsByCourse) === null || _state_announcementsByCourse === void 0 ? void 0 : (_state_announcementsByCourse_clear = _state_announcementsByCourse.clear) === null || _state_announcementsByCourse_clear === void 0 ? void 0 : _state_announcementsByCourse_clear.call(_state_announcementsByCourse);\n    state.messageThreads = [];\n    (_state_participantsByThread = state.participantsByThread) === null || _state_participantsByThread === void 0 ? void 0 : (_state_participantsByThread_clear = _state_participantsByThread.clear) === null || _state_participantsByThread_clear === void 0 ? void 0 : _state_participantsByThread_clear.call(_state_participantsByThread);\n    (_state_messagesByThread = state.messagesByThread) === null || _state_messagesByThread === void 0 ? void 0 : (_state_messagesByThread_clear = _state_messagesByThread.clear) === null || _state_messagesByThread_clear === void 0 ? void 0 : _state_messagesByThread_clear.call(_state_messagesByThread);\n    (_state_filesById = state.filesById) === null || _state_filesById === void 0 ? void 0 : (_state_filesById_clear = _state_filesById.clear) === null || _state_filesById_clear === void 0 ? void 0 : _state_filesById_clear.call(_state_filesById);\n}\nfunction deleteTestCourse(courseId) {\n    state.courses.delete(courseId);\n    state.lessonsByCourse.delete(courseId);\n// Note: we intentionally do not clear enrollments to keep history unless needed\n}\nfunction reorderTestLessons(courseId, updates) {\n    var _state_lessonsByCourse_get;\n    const arr = (_state_lessonsByCourse_get = state.lessonsByCourse.get(courseId)) !== null && _state_lessonsByCourse_get !== void 0 ? _state_lessonsByCourse_get : [];\n    const byId = new Map(arr.map((l)=>[\n            l.id,\n            l\n        ]));\n    for (const u of updates){\n        const row = byId.get(u.id);\n        if (row) row.order_index = u.order_index;\n    }\n    arr.sort((a, b)=>a.order_index - b.order_index);\n    state.lessonsByCourse.set(courseId, arr);\n}\nfunction addTestModule(row) {\n    var _state_modulesByCourse_get;\n    const arr = (_state_modulesByCourse_get = state.modulesByCourse.get(row.course_id)) !== null && _state_modulesByCourse_get !== void 0 ? _state_modulesByCourse_get : [];\n    arr.push(row);\n    arr.sort((a, b)=>a.order_index - b.order_index);\n    state.modulesByCourse.set(row.course_id, arr);\n}\nfunction listTestModulesByCourse(courseId) {\n    var _state_modulesByCourse_get;\n    return (_state_modulesByCourse_get = state.modulesByCourse.get(courseId)) !== null && _state_modulesByCourse_get !== void 0 ? _state_modulesByCourse_get : [];\n}\nfunction updateTestModule(id, data) {\n    for (const [courseId, arr] of state.modulesByCourse.entries()){\n        const idx = arr.findIndex((m)=>m.id === id);\n        if (idx >= 0) {\n            const updated = {\n                ...arr[idx],\n                ...data\n            };\n            arr[idx] = updated;\n            arr.sort((a, b)=>a.order_index - b.order_index);\n            state.modulesByCourse.set(courseId, arr);\n            return updated;\n        }\n    }\n    return undefined;\n}\nfunction deleteTestModule(id) {\n    for (const [courseId, arr] of state.modulesByCourse.entries()){\n        const filtered = arr.filter((m)=>m.id !== id);\n        if (filtered.length !== arr.length) {\n            state.modulesByCourse.set(courseId, filtered);\n            break;\n        }\n    }\n}\nfunction addTestEnrollment(row) {\n    var _state_enrollmentsByStudent_get;\n    const a = (_state_enrollmentsByStudent_get = state.enrollmentsByStudent.get(row.student_id)) !== null && _state_enrollmentsByStudent_get !== void 0 ? _state_enrollmentsByStudent_get : [];\n    a.push(row);\n    state.enrollmentsByStudent.set(row.student_id, a);\n    var _state_enrollmentsByCourse_get;\n    const b = (_state_enrollmentsByCourse_get = state.enrollmentsByCourse.get(row.course_id)) !== null && _state_enrollmentsByCourse_get !== void 0 ? _state_enrollmentsByCourse_get : [];\n    b.push(row);\n    state.enrollmentsByCourse.set(row.course_id, b);\n}\nfunction listTestEnrollmentsByStudent(studentId) {\n    var _state_enrollmentsByStudent_get;\n    return (_state_enrollmentsByStudent_get = state.enrollmentsByStudent.get(studentId)) !== null && _state_enrollmentsByStudent_get !== void 0 ? _state_enrollmentsByStudent_get : [];\n}\nfunction listTestEnrollmentsByCourse(courseId) {\n    var _state_enrollmentsByCourse_get;\n    return (_state_enrollmentsByCourse_get = state.enrollmentsByCourse.get(courseId)) !== null && _state_enrollmentsByCourse_get !== void 0 ? _state_enrollmentsByCourse_get : [];\n}\nfunction upsertTestProfile(profile) {\n    state.profilesById.set(profile.id, profile);\n}\nfunction getTestProfile(id) {\n    return state.profilesById.get(id);\n}\nfunction addTestParentLink(row) {\n    var _state_parentLinksByParent_get;\n    const a = (_state_parentLinksByParent_get = state.parentLinksByParent.get(row.parent_id)) !== null && _state_parentLinksByParent_get !== void 0 ? _state_parentLinksByParent_get : [];\n    a.push(row);\n    state.parentLinksByParent.set(row.parent_id, a);\n}\nfunction listTestParentChildren(parentId) {\n    var _state_parentLinksByParent_get;\n    return (_state_parentLinksByParent_get = state.parentLinksByParent.get(parentId)) !== null && _state_parentLinksByParent_get !== void 0 ? _state_parentLinksByParent_get : [];\n}\nfunction removeTestParentLink(parentId, studentId) {\n    var _state_parentLinksByParent_get;\n    const a = (_state_parentLinksByParent_get = state.parentLinksByParent.get(parentId)) !== null && _state_parentLinksByParent_get !== void 0 ? _state_parentLinksByParent_get : [];\n    const b = a.filter((x)=>x.student_id !== studentId);\n    state.parentLinksByParent.set(parentId, b);\n}\nfunction listTestParentsForStudent(studentId) {\n    const res = [];\n    for (const [pid, arr] of state.parentLinksByParent.entries()){\n        if ((arr !== null && arr !== void 0 ? arr : []).some((pl)=>pl.student_id === studentId)) res.push(pid);\n    }\n    return res;\n}\n// Announcements helpers (test-mode)\nfunction addTestAnnouncement(row) {\n    const s = state;\n    var _s_announcementsByCourse_get;\n    const arr = (_s_announcementsByCourse_get = s.announcementsByCourse.get(row.course_id)) !== null && _s_announcementsByCourse_get !== void 0 ? _s_announcementsByCourse_get : [];\n    arr.unshift(row);\n    s.announcementsByCourse.set(row.course_id, arr);\n}\nfunction listTestAnnouncementsByCourse(courseId) {\n    const s = state;\n    var _s_announcementsByCourse_get;\n    return ((_s_announcementsByCourse_get = s.announcementsByCourse.get(courseId)) !== null && _s_announcementsByCourse_get !== void 0 ? _s_announcementsByCourse_get : []).slice();\n}\nfunction deleteTestAnnouncement(id) {\n    const s = state;\n    for (const [cid, arr] of s.announcementsByCourse.entries()){\n        const next = arr.filter((x)=>x.id !== id);\n        if (next.length !== arr.length) {\n            s.announcementsByCourse.set(cid, next);\n            return {\n                ok: true\n            };\n        }\n    }\n    return {\n        ok: false\n    };\n}\n// ===== Messaging helpers (test-mode) =====\nfunction createTestThread(participantIds, roles) {\n    const id = makeId(\"th\");\n    const created_at = new Date().toISOString();\n    const s = state;\n    s.messageThreads.push({\n        id,\n        created_at\n    });\n    const parts = participantIds.map((uid)=>{\n        var _roles_uid;\n        return {\n            thread_id: id,\n            user_id: uid,\n            role: (_roles_uid = roles === null || roles === void 0 ? void 0 : roles[uid]) !== null && _roles_uid !== void 0 ? _roles_uid : \"user\",\n            added_at: created_at\n        };\n    });\n    s.participantsByThread.set(id, parts);\n    return {\n        id,\n        created_at\n    };\n}\nfunction listTestThreadsByUser(userId) {\n    const s = state;\n    const res = [];\n    for (const t of s.messageThreads){\n        var _s_participantsByThread_get;\n        const parts = (_s_participantsByThread_get = s.participantsByThread.get(t.id)) !== null && _s_participantsByThread_get !== void 0 ? _s_participantsByThread_get : [];\n        if (parts.some((p)=>p.user_id === userId)) res.push(t);\n    }\n    // newest first\n    res.sort((a, b)=>b.created_at.localeCompare(a.created_at));\n    return res;\n}\nfunction addTestMessage(row) {\n    const id = makeId(\"ms\");\n    const created_at = new Date().toISOString();\n    const msg = {\n        id,\n        thread_id: row.thread_id,\n        sender_id: row.sender_id,\n        body: row.body,\n        created_at,\n        read_at: null\n    };\n    const s = state;\n    var _s_messagesByThread_get;\n    const arr = (_s_messagesByThread_get = s.messagesByThread.get(row.thread_id)) !== null && _s_messagesByThread_get !== void 0 ? _s_messagesByThread_get : [];\n    arr.push(msg);\n    arr.sort((a, b)=>a.created_at.localeCompare(b.created_at));\n    s.messagesByThread.set(row.thread_id, arr);\n    // Initialize read receipts map\n    if (!s.readByMessage) s.readByMessage = new Map();\n    s.readByMessage.set(id, new Set());\n    return msg;\n}\nfunction listTestMessagesByThread(threadId) {\n    const s = state;\n    var _s_messagesByThread_get;\n    return ((_s_messagesByThread_get = s.messagesByThread.get(threadId)) !== null && _s_messagesByThread_get !== void 0 ? _s_messagesByThread_get : []).slice();\n}\nfunction markTestMessageReadForUser(messageId, userId) {\n    const s = state;\n    if (!s.readByMessage) s.readByMessage = new Map();\n    var _s_readByMessage_get;\n    const set = (_s_readByMessage_get = s.readByMessage.get(messageId)) !== null && _s_readByMessage_get !== void 0 ? _s_readByMessage_get : new Set();\n    set.add(userId);\n    s.readByMessage.set(messageId, set);\n    // Keep legacy read_at for basic UIs\n    for (const [tid, arr] of s.messagesByThread.entries()){\n        const idx = arr.findIndex((m)=>m.id === messageId);\n        if (idx >= 0) {\n            if (!arr[idx].read_at) arr[idx] = {\n                ...arr[idx],\n                read_at: new Date().toISOString()\n            };\n            s.messagesByThread.set(tid, arr);\n            return arr[idx];\n        }\n    }\n    return null;\n}\nfunction countUnreadForThread(threadId, userId) {\n    const s = state;\n    if (!s.readByMessage) s.readByMessage = new Map();\n    var _s_messagesByThread_get;\n    const msgs = (_s_messagesByThread_get = s.messagesByThread.get(threadId)) !== null && _s_messagesByThread_get !== void 0 ? _s_messagesByThread_get : [];\n    let count = 0;\n    for (const m of msgs){\n        if (m.sender_id === userId) continue;\n        const readSet = s.readByMessage.get(m.id);\n        if (!readSet || !readSet.has(userId)) count++;\n    }\n    return count;\n}\nfunction markAllThreadMessagesReadForUser(threadId, userId) {\n    const s = state;\n    if (!s.readByMessage) s.readByMessage = new Map();\n    var _s_messagesByThread_get;\n    const msgs = (_s_messagesByThread_get = s.messagesByThread.get(threadId)) !== null && _s_messagesByThread_get !== void 0 ? _s_messagesByThread_get : [];\n    for (const m of msgs){\n        if (m.sender_id === userId) continue;\n        var _s_readByMessage_get;\n        const set = (_s_readByMessage_get = s.readByMessage.get(m.id)) !== null && _s_readByMessage_get !== void 0 ? _s_readByMessage_get : new Set();\n        set.add(userId);\n        s.readByMessage.set(m.id, set);\n    }\n    return {\n        ok: true\n    };\n}\n// ===== Feature Flags (test-mode) =====\nfunction listTestFeatureFlags() {\n    const s = state;\n    if (!s.featureFlags) s.featureFlags = new Map();\n    const obj = {};\n    for (const [k, v] of s.featureFlags.entries())obj[k] = !!v;\n    return obj;\n}\nfunction setTestFeatureFlag(key, value) {\n    const s = state;\n    if (!s.featureFlags) s.featureFlags = new Map();\n    s.featureFlags.set(key, !!value);\n    return {\n        key,\n        value: !!value\n    };\n}\nfunction listTestParticipantsByThread(threadId) {\n    const s = state;\n    var _s_participantsByThread_get;\n    return ((_s_participantsByThread_get = s.participantsByThread.get(threadId)) !== null && _s_participantsByThread_get !== void 0 ? _s_participantsByThread_get : []).slice();\n}\n// ===== Notifications helpers (test-mode) =====\nfunction addTestNotification(row) {\n    const s = state;\n    if (!s.notificationsByUser) s.notificationsByUser = new Map();\n    var _row_id;\n    const id = (_row_id = row.id) !== null && _row_id !== void 0 ? _row_id : makeId(\"no\");\n    const created_at = new Date().toISOString();\n    var _row_payload;\n    const obj = {\n        id,\n        user_id: row.user_id,\n        type: row.type,\n        payload: (_row_payload = row.payload) !== null && _row_payload !== void 0 ? _row_payload : {},\n        created_at,\n        read_at: null\n    };\n    var _s_notificationsByUser_get;\n    const arr = (_s_notificationsByUser_get = s.notificationsByUser.get(row.user_id)) !== null && _s_notificationsByUser_get !== void 0 ? _s_notificationsByUser_get : [];\n    arr.unshift(obj);\n    s.notificationsByUser.set(row.user_id, arr);\n    return obj;\n}\nfunction listTestNotificationsByUser(userId) {\n    const s = state;\n    if (!s.notificationsByUser) s.notificationsByUser = new Map();\n    var _s_notificationsByUser_get;\n    return ((_s_notificationsByUser_get = s.notificationsByUser.get(userId)) !== null && _s_notificationsByUser_get !== void 0 ? _s_notificationsByUser_get : []).slice();\n}\nfunction markTestNotificationRead(id) {\n    const s = state;\n    if (!s.notificationsByUser) s.notificationsByUser = new Map();\n    for (const [uid, arr] of s.notificationsByUser.entries()){\n        const idx = arr.findIndex((n)=>n.id === id);\n        if (idx >= 0) {\n            arr[idx] = {\n                ...arr[idx],\n                read_at: new Date().toISOString()\n            };\n            s.notificationsByUser.set(uid, arr);\n            return arr[idx];\n        }\n    }\n    return null;\n}\nfunction markAllTestNotificationsRead(userId) {\n    const s = state;\n    if (!s.notificationsByUser) s.notificationsByUser = new Map();\n    var _s_notificationsByUser_get;\n    const arr = ((_s_notificationsByUser_get = s.notificationsByUser.get(userId)) !== null && _s_notificationsByUser_get !== void 0 ? _s_notificationsByUser_get : []).map((n)=>{\n        var _n_read_at;\n        return {\n            ...n,\n            read_at: (_n_read_at = n.read_at) !== null && _n_read_at !== void 0 ? _n_read_at : new Date().toISOString()\n        };\n    });\n    s.notificationsByUser.set(userId, arr);\n    return {\n        ok: true\n    };\n}\nconst DEFAULT_PREFS = {\n    \"assignment:new\": true,\n    \"submission:graded\": true,\n    \"message:new\": true,\n    \"announcement:published\": true,\n    \"quiz:due-soon\": true\n};\nfunction getTestNotificationPreferences(userId) {\n    const s = state;\n    if (!s.notificationPrefsByUser) s.notificationPrefsByUser = new Map();\n    const current = s.notificationPrefsByUser.get(userId);\n    if (current) return {\n        ...DEFAULT_PREFS,\n        ...current\n    };\n    return {\n        ...DEFAULT_PREFS\n    };\n}\nfunction setTestNotificationPreferences(userId, partial) {\n    const s = state;\n    if (!s.notificationPrefsByUser) s.notificationPrefsByUser = new Map();\n    const merged = {\n        ...getTestNotificationPreferences(userId),\n        ...partial\n    };\n    s.notificationPrefsByUser.set(userId, merged);\n    return merged;\n}\nfunction shouldDeliverTestNotification(userId, type) {\n    const prefs = getTestNotificationPreferences(userId);\n    const val = prefs[type];\n    return val === undefined ? true : !!val;\n}\n// Assignments helpers\nfunction addTestAssignment(row) {\n    const s = state;\n    var _s_assignmentsByCourse_get;\n    const arr = (_s_assignmentsByCourse_get = s.assignmentsByCourse.get(row.course_id)) !== null && _s_assignmentsByCourse_get !== void 0 ? _s_assignmentsByCourse_get : [];\n    arr.push(row);\n    arr.sort((a, b)=>new Date(b.created_at).getTime() - new Date(a.created_at).getTime());\n    s.assignmentsByCourse.set(row.course_id, arr);\n}\nfunction listTestAssignmentsByCourse(courseId) {\n    const s = state;\n    var _s_assignmentsByCourse_get;\n    return (_s_assignmentsByCourse_get = s.assignmentsByCourse.get(courseId)) !== null && _s_assignmentsByCourse_get !== void 0 ? _s_assignmentsByCourse_get : [];\n}\nfunction updateTestAssignment(id, data) {\n    const s = state;\n    for (const [courseId, arr] of s.assignmentsByCourse.entries()){\n        const idx = arr.findIndex((x)=>x.id === id);\n        if (idx >= 0) {\n            const next = {\n                ...arr[idx],\n                ...data\n            };\n            arr[idx] = next;\n            s.assignmentsByCourse.set(courseId, arr);\n            return next;\n        }\n    }\n    return null;\n}\nfunction deleteTestAssignment(id) {\n    const s = state;\n    for (const [courseId, arr] of s.assignmentsByCourse.entries()){\n        const next = arr.filter((x)=>x.id !== id);\n        s.assignmentsByCourse.set(courseId, next);\n    }\n    return {\n        ok: true\n    };\n}\n// ===== Files (test-mode) =====\nfunction addTestFile(input) {\n    const id = makeId(\"f\");\n    const row = {\n        id,\n        owner_type: input.owner_type,\n        owner_id: input.owner_id,\n        content_type: input.content_type,\n        data_base64: input.data_base64,\n        created_at: new Date().toISOString()\n    };\n    const s = state;\n    s.filesById.set(id, row);\n    return row;\n}\nfunction getTestFile(id) {\n    const s = state;\n    var _s_filesById_get;\n    return (_s_filesById_get = s.filesById.get(id)) !== null && _s_filesById_get !== void 0 ? _s_filesById_get : null;\n}\n// Submissions helpers\nfunction addTestSubmission(row) {\n    const s = state;\n    var _s_submissionsByAssignment_get;\n    const arr = (_s_submissionsByAssignment_get = s.submissionsByAssignment.get(row.assignment_id)) !== null && _s_submissionsByAssignment_get !== void 0 ? _s_submissionsByAssignment_get : [];\n    arr.unshift(row);\n    s.submissionsByAssignment.set(row.assignment_id, arr);\n}\nfunction listTestSubmissionsByAssignment(assignmentId) {\n    const s = state;\n    var _s_submissionsByAssignment_get;\n    return (_s_submissionsByAssignment_get = s.submissionsByAssignment.get(assignmentId)) !== null && _s_submissionsByAssignment_get !== void 0 ? _s_submissionsByAssignment_get : [];\n}\nfunction gradeTestSubmission(id, data) {\n    const s = state;\n    for (const [aid, arr] of s.submissionsByAssignment.entries()){\n        const idx = arr.findIndex((x)=>x.id === id);\n        if (idx >= 0) {\n            var _data_feedback;\n            const next = {\n                ...arr[idx],\n                score: data.score,\n                feedback: (_data_feedback = data.feedback) !== null && _data_feedback !== void 0 ? _data_feedback : null\n            };\n            arr[idx] = next;\n            s.submissionsByAssignment.set(aid, arr);\n            return next;\n        }\n    }\n    return null;\n}\nfunction makeId(_prefix) {\n    const hex = \"0123456789abcdef\";\n    const rand = (n)=>Array.from({\n            length: n\n        }, ()=>hex[Math.floor(Math.random() * hex.length)]).join(\"\");\n    const s1 = rand(8);\n    const s2 = rand(4);\n    const s3 = rand(4);\n    const s4 = rand(4);\n    const s5 = rand(12);\n    return \"\".concat(s1, \"-\").concat(s2, \"-\").concat(s3, \"-\").concat(s4, \"-\").concat(s5);\n}\nfunction addQuiz(input) {\n    var _input_time_limit_sec, _input_points;\n    const row = {\n        id: makeId(\"q\"),\n        course_id: input.course_id,\n        title: input.title,\n        time_limit_sec: (_input_time_limit_sec = input.time_limit_sec) !== null && _input_time_limit_sec !== void 0 ? _input_time_limit_sec : null,\n        points: (_input_points = input.points) !== null && _input_points !== void 0 ? _input_points : 100,\n        created_at: new Date().toISOString()\n    };\n    const s = state;\n    var _s_quizzesByCourse_get;\n    const arr = (_s_quizzesByCourse_get = s.quizzesByCourse.get(row.course_id)) !== null && _s_quizzesByCourse_get !== void 0 ? _s_quizzesByCourse_get : [];\n    arr.unshift(row);\n    s.quizzesByCourse.set(row.course_id, arr);\n    return row;\n}\nfunction listQuizzesByCourse(courseId) {\n    const s = state;\n    var _s_quizzesByCourse_get;\n    return ((_s_quizzesByCourse_get = s.quizzesByCourse.get(courseId)) !== null && _s_quizzesByCourse_get !== void 0 ? _s_quizzesByCourse_get : []).slice();\n}\nfunction updateQuiz(id, data) {\n    const s = state;\n    for (const [courseId, arr] of s.quizzesByCourse.entries()){\n        const idx = arr.findIndex((q)=>q.id === id);\n        if (idx >= 0) {\n            const q = arr[idx];\n            const updated = {\n                ...q,\n                ...data\n            };\n            arr[idx] = updated;\n            s.quizzesByCourse.set(courseId, arr);\n            return updated;\n        }\n    }\n    return null;\n}\nfunction deleteQuiz(id) {\n    const s = state;\n    for (const [courseId, arr] of s.quizzesByCourse.entries()){\n        const next = arr.filter((q)=>q.id !== id);\n        if (next.length !== arr.length) {\n            s.quizzesByCourse.set(courseId, next);\n            // Cascade: remove questions for this quiz\n            s.questionsByQuiz.delete(id);\n            return {\n                ok: true\n            };\n        }\n    }\n    return {\n        ok: false\n    };\n}\nfunction addQuestion(input) {\n    var _input_order_index;\n    const row = {\n        id: makeId(\"r\"),\n        quiz_id: input.quiz_id,\n        text: input.text,\n        order_index: (_input_order_index = input.order_index) !== null && _input_order_index !== void 0 ? _input_order_index : 1\n    };\n    const s = state;\n    var _s_questionsByQuiz_get;\n    const arr = (_s_questionsByQuiz_get = s.questionsByQuiz.get(row.quiz_id)) !== null && _s_questionsByQuiz_get !== void 0 ? _s_questionsByQuiz_get : [];\n    arr.push(row);\n    arr.sort((a, b)=>a.order_index - b.order_index);\n    s.questionsByQuiz.set(row.quiz_id, arr);\n    return row;\n}\nfunction listQuestionsByQuiz(quizId) {\n    const s = state;\n    var _s_questionsByQuiz_get;\n    return ((_s_questionsByQuiz_get = s.questionsByQuiz.get(quizId)) !== null && _s_questionsByQuiz_get !== void 0 ? _s_questionsByQuiz_get : []).slice();\n}\nfunction addChoice(input) {\n    var _input_order_index;\n    const row = {\n        id: makeId(\"s\"),\n        question_id: input.question_id,\n        text: input.text,\n        correct: input.correct,\n        order_index: (_input_order_index = input.order_index) !== null && _input_order_index !== void 0 ? _input_order_index : 1\n    };\n    const s = state;\n    var _s_choicesByQuestion_get;\n    const arr = (_s_choicesByQuestion_get = s.choicesByQuestion.get(row.question_id)) !== null && _s_choicesByQuestion_get !== void 0 ? _s_choicesByQuestion_get : [];\n    arr.push(row);\n    arr.sort((a, b)=>a.order_index - b.order_index);\n    s.choicesByQuestion.set(row.question_id, arr);\n    return row;\n}\nfunction listChoicesByQuestion(questionId) {\n    const s = state;\n    var _s_choicesByQuestion_get;\n    return ((_s_choicesByQuestion_get = s.choicesByQuestion.get(questionId)) !== null && _s_choicesByQuestion_get !== void 0 ? _s_choicesByQuestion_get : []).slice();\n}\nfunction startAttempt(input) {\n    const row = {\n        id: makeId(\"t\"),\n        quiz_id: input.quiz_id,\n        student_id: input.student_id,\n        started_at: new Date().toISOString(),\n        submitted_at: null,\n        score: 0\n    };\n    const s = state;\n    var _s_attemptsByQuiz_get;\n    const arr = (_s_attemptsByQuiz_get = s.attemptsByQuiz.get(row.quiz_id)) !== null && _s_attemptsByQuiz_get !== void 0 ? _s_attemptsByQuiz_get : [];\n    arr.push(row);\n    s.attemptsByQuiz.set(row.quiz_id, arr);\n    return row;\n}\nfunction upsertAnswer(input) {\n    const s = state;\n    var _s_answersByAttempt_get;\n    const ansArr = (_s_answersByAttempt_get = s.answersByAttempt.get(input.attempt_id)) !== null && _s_answersByAttempt_get !== void 0 ? _s_answersByAttempt_get : [];\n    const idx = ansArr.findIndex((a)=>a.question_id === input.question_id);\n    const row = idx >= 0 ? {\n        ...ansArr[idx],\n        choice_id: input.choice_id,\n        created_at: new Date().toISOString()\n    } : {\n        id: makeId(\"u\"),\n        attempt_id: input.attempt_id,\n        question_id: input.question_id,\n        choice_id: input.choice_id,\n        created_at: new Date().toISOString()\n    };\n    if (idx >= 0) ansArr[idx] = row;\n    else ansArr.push(row);\n    s.answersByAttempt.set(input.attempt_id, ansArr);\n    return row;\n}\nfunction submitAttempt(input) {\n    const s = state;\n    let attempt;\n    let quizId;\n    for (const [qid, arr] of s.attemptsByQuiz.entries()){\n        const found = arr.find((a)=>a.id === input.attempt_id);\n        if (found) {\n            attempt = found;\n            quizId = qid;\n            break;\n        }\n    }\n    if (!attempt || !quizId) return null;\n    var _s_questionsByQuiz_get;\n    const questions = (_s_questionsByQuiz_get = s.questionsByQuiz.get(quizId)) !== null && _s_questionsByQuiz_get !== void 0 ? _s_questionsByQuiz_get : [];\n    const total = questions.length;\n    var _s_answersByAttempt_get;\n    const answers = (_s_answersByAttempt_get = s.answersByAttempt.get(attempt.id)) !== null && _s_answersByAttempt_get !== void 0 ? _s_answersByAttempt_get : [];\n    let correct = 0;\n    for (const q of questions){\n        const a = answers.find((x)=>x.question_id === q.id);\n        if (!a) continue;\n        var _s_choicesByQuestion_get;\n        const choices = (_s_choicesByQuestion_get = s.choicesByQuestion.get(q.id)) !== null && _s_choicesByQuestion_get !== void 0 ? _s_choicesByQuestion_get : [];\n        const correctChoice = choices.find((c)=>c.correct);\n        if (correctChoice && a.choice_id === correctChoice.id) correct++;\n    }\n    let quizPoints = 100;\n    for (const [, quizzes] of s.quizzesByCourse.entries()){\n        const match = quizzes.find((q)=>q.id === quizId);\n        if (match) {\n            quizPoints = match.points;\n            break;\n        }\n    }\n    const score = total > 0 ? Math.round(correct / total * quizPoints) : 0;\n    attempt.submitted_at = new Date().toISOString();\n    attempt.score = score;\n    return attempt;\n}\nfunction listAttemptsForQuiz(quiz_id) {\n    const s = state;\n    var _s_attemptsByQuiz_get;\n    return ((_s_attemptsByQuiz_get = s.attemptsByQuiz.get(quiz_id)) !== null && _s_attemptsByQuiz_get !== void 0 ? _s_attemptsByQuiz_get : []).slice();\n}\nfunction getAttemptForStudent(quiz_id, student_id) {\n    const s = state;\n    var _s_attemptsByQuiz_get;\n    const arr = (_s_attemptsByQuiz_get = s.attemptsByQuiz.get(quiz_id)) !== null && _s_attemptsByQuiz_get !== void 0 ? _s_attemptsByQuiz_get : [];\n    const mine = arr.filter((a)=>a.student_id === student_id);\n    if (mine.length === 0) return null;\n    mine.sort((a, b)=>b.started_at.localeCompare(a.started_at));\n    return mine[0];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdGVzdFN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQW1FRCxrRUFBa0U7QUFDbEUsTUFBTUEsY0FBY0M7QUFDcEIsTUFBTUMsUUEwQkZGLFlBQVlHLGNBQWMsSUFBS0gsQ0FBQUEsWUFBWUcsY0FBYyxHQUFHO0lBQzlEQyxTQUFTLElBQUlDO0lBQ2JDLGlCQUFpQixJQUFJRDtJQUNyQkUsaUJBQWlCLElBQUlGO0lBQ3JCRyxzQkFBc0IsSUFBSUg7SUFDMUJJLHFCQUFxQixJQUFJSjtJQUN6QkssY0FBYyxJQUFJTDtJQUNsQk0scUJBQXFCLElBQUlOO0FBQzNCO0FBRUEsOEZBQThGO0FBQzlGLE1BQU1PLFdBQVdWO0FBQ2pCLElBQUksQ0FBQ1UsU0FBU0YsWUFBWSxFQUFFRSxTQUFTRixZQUFZLEdBQUcsSUFBSUw7QUFDeEQsSUFBSSxDQUFDTyxTQUFTRCxtQkFBbUIsRUFBRUMsU0FBU0QsbUJBQW1CLEdBQUcsSUFBSU47QUFDdEUsSUFBSSxDQUFDTyxTQUFTTCxlQUFlLEVBQUVLLFNBQVNMLGVBQWUsR0FBRyxJQUFJRjtBQUM5RCxJQUFJLENBQUNPLFNBQVNDLG1CQUFtQixFQUFFRCxTQUFTQyxtQkFBbUIsR0FBRyxJQUFJUjtBQUN0RSxJQUFJLENBQUNPLFNBQVNFLHVCQUF1QixFQUFFRixTQUFTRSx1QkFBdUIsR0FBRyxJQUFJVDtBQUM5RSxtREFBbUQ7QUFDbkQsSUFBSSxDQUFDTyxTQUFTRyxlQUFlLEVBQUVILFNBQVNHLGVBQWUsR0FBRyxJQUFJVjtBQUM5RCxJQUFJLENBQUNPLFNBQVNJLGVBQWUsRUFBRUosU0FBU0ksZUFBZSxHQUFHLElBQUlYO0FBQzlELElBQUksQ0FBQ08sU0FBU0ssaUJBQWlCLEVBQUVMLFNBQVNLLGlCQUFpQixHQUFHLElBQUlaO0FBQ2xFLElBQUksQ0FBQ08sU0FBU00sY0FBYyxFQUFFTixTQUFTTSxjQUFjLEdBQUcsSUFBSWI7QUFDNUQsSUFBSSxDQUFDTyxTQUFTTyxnQkFBZ0IsRUFBRVAsU0FBU08sZ0JBQWdCLEdBQUcsSUFBSWQ7QUFDaEUsSUFBSSxDQUFDTyxTQUFTUSxxQkFBcUIsRUFBRVIsU0FBU1EscUJBQXFCLEdBQUcsSUFBSWY7QUFDMUUsSUFBSSxDQUFDTyxTQUFTUyxTQUFTLEVBQUVULFNBQVNTLFNBQVMsR0FBRyxJQUFJaEI7QUFDbEQsaUJBQWlCO0FBQ2pCLElBQUksQ0FBQ08sU0FBU1UsY0FBYyxFQUFFVixTQUFTVSxjQUFjLEdBQUcsRUFBRTtBQUMxRCxJQUFJLENBQUNWLFNBQVNXLG9CQUFvQixFQUFFWCxTQUFTVyxvQkFBb0IsR0FBRyxJQUFJbEI7QUFDeEUsSUFBSSxDQUFDTyxTQUFTWSxnQkFBZ0IsRUFBRVosU0FBU1ksZ0JBQWdCLEdBQUcsSUFBSW5CO0FBQ2hFLElBQUksQ0FBQ08sU0FBU2EsYUFBYSxFQUFFYixTQUFTYSxhQUFhLEdBQUcsSUFBSXBCO0FBQzFELElBQUksQ0FBQ08sU0FBU2MsWUFBWSxFQUFFZCxTQUFTYyxZQUFZLEdBQUcsSUFBSXJCO0FBRWpELFNBQVNzQixjQUFjQyxNQUFrQjtJQUM5QzFCLE1BQU1FLE9BQU8sQ0FBQ3lCLEdBQUcsQ0FBQ0QsT0FBT0UsRUFBRSxFQUFFRjtBQUMvQjtBQUVPLFNBQVNHLGNBQWNDLFFBQWdCO0lBQzVDLE9BQU85QixNQUFNRSxPQUFPLENBQUM2QixHQUFHLENBQUNEO0FBQzNCO0FBRU8sU0FBU0UseUJBQXlCQyxTQUFpQjtJQUN4RCxPQUFPQyxNQUFNQyxJQUFJLENBQUNuQyxNQUFNRSxPQUFPLENBQUNrQyxNQUFNLElBQUlDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsVUFBVSxLQUFLTjtBQUN6RTtBQUVPLFNBQVNPLGNBQWNDLE1BQWtCO1FBQ2xDekM7SUFBWixNQUFNMEMsTUFBTTFDLENBQUFBLDZCQUFBQSxNQUFNSSxlQUFlLENBQUMyQixHQUFHLENBQUNVLE9BQU9FLFNBQVMsZUFBMUMzQyx3Q0FBQUEsNkJBQStDLEVBQUU7SUFDN0QwQyxJQUFJRSxJQUFJLENBQUNIO0lBQ1RDLElBQUlHLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFRSxXQUFXLEdBQUdELEVBQUVDLFdBQVc7SUFDaERoRCxNQUFNSSxlQUFlLENBQUN1QixHQUFHLENBQUNjLE9BQU9FLFNBQVMsRUFBRUQ7QUFDOUM7QUFFTyxTQUFTTyx3QkFBd0JuQixRQUFnQjtRQUMvQzlCO0lBQVAsT0FBT0EsQ0FBQUEsNkJBQUFBLE1BQU1JLGVBQWUsQ0FBQzJCLEdBQUcsQ0FBQ0QsdUJBQTFCOUIsd0NBQUFBLDZCQUF1QyxFQUFFO0FBQ2xEO0FBRU8sU0FBU2tEO1FBT2QsOERBQ0Esc0VBRUEsc0RBQ0Esc0RBQ0EsMERBQ0Esb0RBQ0Esd0RBQ0Esa0VBRUEsZ0VBQ0Esd0RBQ0E7SUFsQkFsRCxNQUFNRSxPQUFPLENBQUNpRCxLQUFLO0lBQ25CbkQsTUFBTUksZUFBZSxDQUFDK0MsS0FBSztJQUMzQm5ELE1BQU1LLGVBQWUsQ0FBQzhDLEtBQUs7SUFDM0JuRCxNQUFNTSxvQkFBb0IsQ0FBQzZDLEtBQUs7SUFDaENuRCxNQUFNTyxtQkFBbUIsQ0FBQzRDLEtBQUs7SUFDL0JuRCxNQUFNUyxtQkFBbUIsQ0FBQzBDLEtBQUs7S0FDL0IsbUNBQWV4QyxtQkFBbUIsY0FBbEMsZ0hBQW9Dd0MsS0FBSyxjQUF6QztLQUNBLHVDQUFldkMsdUJBQXVCLGNBQXRDLDRIQUF3Q3VDLEtBQUssY0FBN0M7S0FFQSxtQ0FEVTtJQUNUbkQsTUFBY2EsZUFBZSxjQUE5QixvR0FBZ0NzQyxLQUFLLGNBQXJDO0tBQ0EsK0JBQWVyQyxlQUFlLGNBQTlCLG9HQUFnQ3FDLEtBQUssY0FBckM7S0FDQSxpQ0FBZXBDLGlCQUFpQixjQUFoQywwR0FBa0NvQyxLQUFLLGNBQXZDO0tBQ0EsOEJBQWVuQyxjQUFjLGNBQTdCLGlHQUErQm1DLEtBQUssY0FBcEM7S0FDQSxnQ0FBZWxDLGdCQUFnQixjQUEvQix1R0FBaUNrQyxLQUFLLGNBQXRDO0tBQ0EscUNBQWVqQyxxQkFBcUIsY0FBcEMsc0hBQXNDaUMsS0FBSyxjQUEzQztJQUNDbkQsTUFBY29CLGNBQWMsR0FBRyxFQUFFO0tBQ2xDLG9DQUFlQyxvQkFBb0IsY0FBbkMsbUhBQXFDOEIsS0FBSyxjQUExQztLQUNBLGdDQUFlN0IsZ0JBQWdCLGNBQS9CLHVHQUFpQzZCLEtBQUssY0FBdEM7S0FDQSx5QkFBZWhDLFNBQVMsY0FBeEIsa0ZBQTBCZ0MsS0FBSyxjQUEvQjtBQUNGO0FBRU8sU0FBU0MsaUJBQWlCdEIsUUFBZ0I7SUFDL0M5QixNQUFNRSxPQUFPLENBQUNtRCxNQUFNLENBQUN2QjtJQUNyQjlCLE1BQU1JLGVBQWUsQ0FBQ2lELE1BQU0sQ0FBQ3ZCO0FBQzdCLGdGQUFnRjtBQUNsRjtBQUVPLFNBQVN3QixtQkFBbUJ4QixRQUFnQixFQUFFeUIsT0FBOEM7UUFDckZ2RDtJQUFaLE1BQU0wQyxNQUFNMUMsQ0FBQUEsNkJBQUFBLE1BQU1JLGVBQWUsQ0FBQzJCLEdBQUcsQ0FBQ0QsdUJBQTFCOUIsd0NBQUFBLDZCQUF1QyxFQUFFO0lBQ3JELE1BQU13RCxPQUFPLElBQUlyRCxJQUFJdUMsSUFBSWUsR0FBRyxDQUFDQyxDQUFBQSxJQUFLO1lBQUNBLEVBQUU5QixFQUFFO1lBQUU4QjtTQUFFO0lBQzNDLEtBQUssTUFBTUMsS0FBS0osUUFBUztRQUN2QixNQUFNSyxNQUFNSixLQUFLekIsR0FBRyxDQUFDNEIsRUFBRS9CLEVBQUU7UUFDekIsSUFBSWdDLEtBQUtBLElBQUlaLFdBQVcsR0FBR1csRUFBRVgsV0FBVztJQUMxQztJQUNBTixJQUFJRyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUUsV0FBVyxHQUFHRCxFQUFFQyxXQUFXO0lBQ2hEaEQsTUFBTUksZUFBZSxDQUFDdUIsR0FBRyxDQUFDRyxVQUFVWTtBQUN0QztBQUVPLFNBQVNtQixjQUFjRCxHQUFlO1FBQy9CNUQ7SUFBWixNQUFNMEMsTUFBTTFDLENBQUFBLDZCQUFBQSxNQUFNSyxlQUFlLENBQUMwQixHQUFHLENBQUM2QixJQUFJakIsU0FBUyxlQUF2QzNDLHdDQUFBQSw2QkFBNEMsRUFBRTtJQUMxRDBDLElBQUlFLElBQUksQ0FBQ2dCO0lBQ1RsQixJQUFJRyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUUsV0FBVyxHQUFHRCxFQUFFQyxXQUFXO0lBQ2hEaEQsTUFBTUssZUFBZSxDQUFDc0IsR0FBRyxDQUFDaUMsSUFBSWpCLFNBQVMsRUFBRUQ7QUFDM0M7QUFFTyxTQUFTb0Isd0JBQXdCaEMsUUFBZ0I7UUFDL0M5QjtJQUFQLE9BQU9BLENBQUFBLDZCQUFBQSxNQUFNSyxlQUFlLENBQUMwQixHQUFHLENBQUNELHVCQUExQjlCLHdDQUFBQSw2QkFBdUMsRUFBRTtBQUNsRDtBQUVPLFNBQVMrRCxpQkFBaUJuQyxFQUFVLEVBQUVvQyxJQUF3RDtJQUNuRyxLQUFLLE1BQU0sQ0FBQ2xDLFVBQVVZLElBQUksSUFBSTFDLE1BQU1LLGVBQWUsQ0FBQzRELE9BQU8sR0FBSTtRQUM3RCxNQUFNQyxNQUFNeEIsSUFBSXlCLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXhDLEVBQUUsS0FBS0E7UUFDeEMsSUFBSXNDLE9BQU8sR0FBRztZQUNaLE1BQU1HLFVBQVU7Z0JBQUUsR0FBRzNCLEdBQUcsQ0FBQ3dCLElBQUk7Z0JBQUUsR0FBR0YsSUFBSTtZQUFDO1lBQ3ZDdEIsR0FBRyxDQUFDd0IsSUFBSSxHQUFHRztZQUNYM0IsSUFBSUcsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVFLFdBQVcsR0FBR0QsRUFBRUMsV0FBVztZQUNoRGhELE1BQU1LLGVBQWUsQ0FBQ3NCLEdBQUcsQ0FBQ0csVUFBVVk7WUFDcEMsT0FBTzJCO1FBQ1Q7SUFDRjtJQUNBLE9BQU9DO0FBQ1Q7QUFFTyxTQUFTQyxpQkFBaUIzQyxFQUFVO0lBQ3pDLEtBQUssTUFBTSxDQUFDRSxVQUFVWSxJQUFJLElBQUkxQyxNQUFNSyxlQUFlLENBQUM0RCxPQUFPLEdBQUk7UUFDN0QsTUFBTU8sV0FBVzlCLElBQUlMLE1BQU0sQ0FBQytCLENBQUFBLElBQUtBLEVBQUV4QyxFQUFFLEtBQUtBO1FBQzFDLElBQUk0QyxTQUFTQyxNQUFNLEtBQUsvQixJQUFJK0IsTUFBTSxFQUFFO1lBQ2xDekUsTUFBTUssZUFBZSxDQUFDc0IsR0FBRyxDQUFDRyxVQUFVMEM7WUFDcEM7UUFDRjtJQUNGO0FBQ0Y7QUFFTyxTQUFTRSxrQkFBa0JkLEdBQW1CO1FBQ3pDNUQ7SUFBVixNQUFNOEMsSUFBSTlDLENBQUFBLGtDQUFBQSxNQUFNTSxvQkFBb0IsQ0FBQ3lCLEdBQUcsQ0FBQzZCLElBQUllLFVBQVUsZUFBN0MzRSw2Q0FBQUEsa0NBQWtELEVBQUU7SUFDOUQ4QyxFQUFFRixJQUFJLENBQUNnQjtJQUNQNUQsTUFBTU0sb0JBQW9CLENBQUNxQixHQUFHLENBQUNpQyxJQUFJZSxVQUFVLEVBQUU3QjtRQUNyQzlDO0lBQVYsTUFBTStDLElBQUkvQyxDQUFBQSxpQ0FBQUEsTUFBTU8sbUJBQW1CLENBQUN3QixHQUFHLENBQUM2QixJQUFJakIsU0FBUyxlQUEzQzNDLDRDQUFBQSxpQ0FBZ0QsRUFBRTtJQUM1RCtDLEVBQUVILElBQUksQ0FBQ2dCO0lBQ1A1RCxNQUFNTyxtQkFBbUIsQ0FBQ29CLEdBQUcsQ0FBQ2lDLElBQUlqQixTQUFTLEVBQUVJO0FBQy9DO0FBRU8sU0FBUzZCLDZCQUE2QkMsU0FBaUI7UUFDckQ3RTtJQUFQLE9BQU9BLENBQUFBLGtDQUFBQSxNQUFNTSxvQkFBb0IsQ0FBQ3lCLEdBQUcsQ0FBQzhDLHdCQUEvQjdFLDZDQUFBQSxrQ0FBNkMsRUFBRTtBQUN4RDtBQUVPLFNBQVM4RSw0QkFBNEJoRCxRQUFnQjtRQUNuRDlCO0lBQVAsT0FBT0EsQ0FBQUEsaUNBQUFBLE1BQU1PLG1CQUFtQixDQUFDd0IsR0FBRyxDQUFDRCx1QkFBOUI5Qiw0Q0FBQUEsaUNBQTJDLEVBQUU7QUFDdEQ7QUFFTyxTQUFTK0Usa0JBQWtCQyxPQUFvQjtJQUNyRGhGLE1BQU1RLFlBQVksQ0FBQ21CLEdBQUcsQ0FBQ3FELFFBQVFwRCxFQUFFLEVBQUVvRDtBQUNwQztBQUVPLFNBQVNDLGVBQWVyRCxFQUFVO0lBQ3hDLE9BQU81QixNQUFNUSxZQUFZLENBQUN1QixHQUFHLENBQUNIO0FBQy9CO0FBRU8sU0FBU3NELGtCQUFrQnRCLEdBQW1CO1FBQzFDNUQ7SUFBVixNQUFNOEMsSUFBSTlDLENBQUFBLGlDQUFBQSxNQUFNUyxtQkFBbUIsQ0FBQ3NCLEdBQUcsQ0FBQzZCLElBQUl1QixTQUFTLGVBQTNDbkYsNENBQUFBLGlDQUFnRCxFQUFFO0lBQzVEOEMsRUFBRUYsSUFBSSxDQUFDZ0I7SUFDUDVELE1BQU1TLG1CQUFtQixDQUFDa0IsR0FBRyxDQUFDaUMsSUFBSXVCLFNBQVMsRUFBRXJDO0FBQzlDO0FBRU8sU0FBU3NDLHVCQUF1QkMsUUFBZ0I7UUFDL0NyRjtJQUFQLE9BQU9BLENBQUFBLGlDQUFBQSxNQUFNUyxtQkFBbUIsQ0FBQ3NCLEdBQUcsQ0FBQ3NELHVCQUE5QnJGLDRDQUFBQSxpQ0FBMkMsRUFBRTtBQUNyRDtBQUVPLFNBQVNzRixxQkFBcUJELFFBQWdCLEVBQUVSLFNBQWlCO1FBQzdEN0U7SUFBVixNQUFNOEMsSUFBSTlDLENBQUFBLGlDQUFBQSxNQUFNUyxtQkFBbUIsQ0FBQ3NCLEdBQUcsQ0FBQ3NELHVCQUE5QnJGLDRDQUFBQSxpQ0FBMkMsRUFBRTtJQUN2RCxNQUFNK0MsSUFBSUQsRUFBRVQsTUFBTSxDQUFDa0QsQ0FBQUEsSUFBS0EsRUFBRVosVUFBVSxLQUFLRTtJQUN6QzdFLE1BQU1TLG1CQUFtQixDQUFDa0IsR0FBRyxDQUFDMEQsVUFBVXRDO0FBQ3pDO0FBRU8sU0FBU3lDLDBCQUEwQlgsU0FBaUI7SUFDMUQsTUFBTVksTUFBZ0IsRUFBRTtJQUN4QixLQUFLLE1BQU0sQ0FBQ0MsS0FBS2hELElBQUksSUFBSTFDLE1BQU1TLG1CQUFtQixDQUFDd0QsT0FBTyxHQUFJO1FBQzdELElBQUksQ0FBQ3ZCLGdCQUFBQSxpQkFBQUEsTUFBTyxFQUFFLEVBQUVpRCxJQUFJLENBQUNDLENBQUFBLEtBQU1BLEdBQUdqQixVQUFVLEtBQUtFLFlBQVlZLElBQUk3QyxJQUFJLENBQUM4QztJQUNuRTtJQUNBLE9BQU9EO0FBQ1I7QUFFQSxvQ0FBb0M7QUFDN0IsU0FBU0ksb0JBQW9CakMsR0FBc0k7SUFDeEssTUFBTWtDLElBQUk5RjtRQUNFOEY7SUFBWixNQUFNcEQsTUFBTW9ELENBQUFBLCtCQUFBQSxFQUFFNUUscUJBQXFCLENBQUNhLEdBQUcsQ0FBQzZCLElBQUlqQixTQUFTLGVBQXpDbUQsMENBQUFBLCtCQUE4QyxFQUFFO0lBQzVEcEQsSUFBSXFELE9BQU8sQ0FBQ25DO0lBQ1prQyxFQUFFNUUscUJBQXFCLENBQUNTLEdBQUcsQ0FBQ2lDLElBQUlqQixTQUFTLEVBQUVEO0FBQzdDO0FBRU8sU0FBU3NELDhCQUE4QmxFLFFBQWdCO0lBQzVELE1BQU1nRSxJQUFJOUY7UUFDRjhGO0lBQVIsT0FBTyxDQUFDQSxDQUFBQSwrQkFBQUEsRUFBRTVFLHFCQUFxQixDQUFDYSxHQUFHLENBQUNELHVCQUE1QmdFLDBDQUFBQSwrQkFBeUMsRUFBRSxFQUFFRyxLQUFLO0FBQzVEO0FBRU8sU0FBU0MsdUJBQXVCdEUsRUFBVTtJQUMvQyxNQUFNa0UsSUFBSTlGO0lBQ1YsS0FBSyxNQUFNLENBQUNtRyxLQUFLekQsSUFBSSxJQUFJb0QsRUFBRTVFLHFCQUFxQixDQUFDK0MsT0FBTyxHQUFJO1FBQzFELE1BQU1tQyxPQUFPMUQsSUFBSUwsTUFBTSxDQUFDLENBQUNrRCxJQUFXQSxFQUFFM0QsRUFBRSxLQUFLQTtRQUM3QyxJQUFJd0UsS0FBSzNCLE1BQU0sS0FBSy9CLElBQUkrQixNQUFNLEVBQUU7WUFDOUJxQixFQUFFNUUscUJBQXFCLENBQUNTLEdBQUcsQ0FBQ3dFLEtBQUtDO1lBQ2pDLE9BQU87Z0JBQUVDLElBQUk7WUFBSztRQUNwQjtJQUNGO0lBQ0EsT0FBTztRQUFFQSxJQUFJO0lBQU07QUFDckI7QUFFQSw0Q0FBNEM7QUFDckMsU0FBU0MsaUJBQWlCQyxjQUF3QixFQUFFQyxLQUE4QjtJQUN2RixNQUFNNUUsS0FBSzZFLE9BQU87SUFDbEIsTUFBTUMsYUFBYSxJQUFJQyxPQUFPQyxXQUFXO0lBQ3pDLE1BQU1kLElBQUk5RjtJQUNWOEYsRUFBRTFFLGNBQWMsQ0FBQ3dCLElBQUksQ0FBQztRQUFFaEI7UUFBSThFO0lBQVc7SUFDdkMsTUFBTUcsUUFBUU4sZUFBZTlDLEdBQUcsQ0FBQ3FELENBQUFBO1lBQTZDTjtlQUFyQztZQUFFTyxXQUFXbkY7WUFBSW9GLFNBQVNGO1lBQUtHLE1BQU1ULENBQUFBLGFBQUFBLGtCQUFBQSw0QkFBQUEsS0FBTyxDQUFDTSxJQUFJLGNBQVpOLHdCQUFBQSxhQUFnQjtZQUFRVSxVQUFVUjtRQUFXO0lBQUE7SUFDM0haLEVBQUV6RSxvQkFBb0IsQ0FBQ00sR0FBRyxDQUFDQyxJQUFJaUY7SUFDL0IsT0FBTztRQUFFakY7UUFBSThFO0lBQVc7QUFDMUI7QUFFTyxTQUFTUyxzQkFBc0JDLE1BQWM7SUFDbEQsTUFBTXRCLElBQUk5RjtJQUNWLE1BQU15RixNQUE0QyxFQUFFO0lBQ3BELEtBQUssTUFBTTRCLEtBQUt2QixFQUFFMUUsY0FBYyxDQUEwQztZQUN6RDBFO1FBQWYsTUFBTWUsUUFBU2YsQ0FBQUEsOEJBQUFBLEVBQUV6RSxvQkFBb0IsQ0FBQ1UsR0FBRyxDQUFDc0YsRUFBRXpGLEVBQUUsZUFBL0JrRSx5Q0FBQUEsOEJBQW9DLEVBQUU7UUFDckQsSUFBSWUsTUFBTWxCLElBQUksQ0FBQzJCLENBQUFBLElBQUtBLEVBQUVOLE9BQU8sS0FBS0ksU0FBUzNCLElBQUk3QyxJQUFJLENBQUN5RTtJQUN0RDtJQUNBLGVBQWU7SUFDZjVCLElBQUk1QyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRTJELFVBQVUsQ0FBQ2EsYUFBYSxDQUFDekUsRUFBRTRELFVBQVU7SUFDMUQsT0FBT2pCO0FBQ1Q7QUFFTyxTQUFTK0IsZUFBZTVELEdBQTJEO0lBQ3hGLE1BQU1oQyxLQUFLNkUsT0FBTztJQUNsQixNQUFNQyxhQUFhLElBQUlDLE9BQU9DLFdBQVc7SUFDekMsTUFBTWEsTUFBTTtRQUFFN0Y7UUFBSW1GLFdBQVduRCxJQUFJbUQsU0FBUztRQUFFVyxXQUFXOUQsSUFBSThELFNBQVM7UUFBRUMsTUFBTS9ELElBQUkrRCxJQUFJO1FBQUVqQjtRQUFZa0IsU0FBUztJQUFLO0lBQ2hILE1BQU05QixJQUFJOUY7UUFDRThGO0lBQVosTUFBTXBELE1BQU1vRCxDQUFBQSwwQkFBQUEsRUFBRXhFLGdCQUFnQixDQUFDUyxHQUFHLENBQUM2QixJQUFJbUQsU0FBUyxlQUFwQ2pCLHFDQUFBQSwwQkFBeUMsRUFBRTtJQUN2RHBELElBQUlFLElBQUksQ0FBQzZFO0lBQ1QvRSxJQUFJRyxJQUFJLENBQUMsQ0FBQ0MsR0FBUUMsSUFBV0QsRUFBRTRELFVBQVUsQ0FBQ2EsYUFBYSxDQUFDeEUsRUFBRTJELFVBQVU7SUFDcEVaLEVBQUV4RSxnQkFBZ0IsQ0FBQ0ssR0FBRyxDQUFDaUMsSUFBSW1ELFNBQVMsRUFBRXJFO0lBQ3RDLCtCQUErQjtJQUMvQixJQUFJLENBQUNvRCxFQUFFdkUsYUFBYSxFQUFFdUUsRUFBRXZFLGFBQWEsR0FBRyxJQUFJcEI7SUFDNUMyRixFQUFFdkUsYUFBYSxDQUFDSSxHQUFHLENBQUNDLElBQUksSUFBSWlHO0lBQzVCLE9BQU9KO0FBQ1Q7QUFFTyxTQUFTSyx5QkFBeUJDLFFBQWdCO0lBQ3ZELE1BQU1qQyxJQUFJOUY7UUFDRjhGO0lBQVIsT0FBTyxDQUFDQSxDQUFBQSwwQkFBQUEsRUFBRXhFLGdCQUFnQixDQUFDUyxHQUFHLENBQUNnRyx1QkFBdkJqQyxxQ0FBQUEsMEJBQW9DLEVBQUUsRUFBRUcsS0FBSztBQUN2RDtBQUVPLFNBQVMrQiwyQkFBMkJDLFNBQWlCLEVBQUViLE1BQWM7SUFDMUUsTUFBTXRCLElBQUk5RjtJQUNWLElBQUksQ0FBQzhGLEVBQUV2RSxhQUFhLEVBQUV1RSxFQUFFdkUsYUFBYSxHQUFHLElBQUlwQjtRQUNoQzJGO0lBQVosTUFBTW5FLE1BQU1tRSxDQUFBQSx1QkFBQUEsRUFBRXZFLGFBQWEsQ0FBQ1EsR0FBRyxDQUFDa0csd0JBQXBCbkMsa0NBQUFBLHVCQUFrQyxJQUFJK0I7SUFDbERsRyxJQUFJdUcsR0FBRyxDQUFDZDtJQUNSdEIsRUFBRXZFLGFBQWEsQ0FBQ0ksR0FBRyxDQUFDc0csV0FBV3RHO0lBQy9CLG9DQUFvQztJQUNwQyxLQUFLLE1BQU0sQ0FBQ3dHLEtBQUt6RixJQUFJLElBQUlvRCxFQUFFeEUsZ0JBQWdCLENBQUMyQyxPQUFPLEdBQUk7UUFDckQsTUFBTUMsTUFBTXhCLElBQUl5QixTQUFTLENBQUMsQ0FBQ0MsSUFBV0EsRUFBRXhDLEVBQUUsS0FBS3FHO1FBQy9DLElBQUkvRCxPQUFPLEdBQUc7WUFDWixJQUFJLENBQUN4QixHQUFHLENBQUN3QixJQUFJLENBQUMwRCxPQUFPLEVBQUVsRixHQUFHLENBQUN3QixJQUFJLEdBQUc7Z0JBQUUsR0FBR3hCLEdBQUcsQ0FBQ3dCLElBQUk7Z0JBQUUwRCxTQUFTLElBQUlqQixPQUFPQyxXQUFXO1lBQUc7WUFDbkZkLEVBQUV4RSxnQkFBZ0IsQ0FBQ0ssR0FBRyxDQUFDd0csS0FBS3pGO1lBQzVCLE9BQU9BLEdBQUcsQ0FBQ3dCLElBQUk7UUFDakI7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVPLFNBQVNrRSxxQkFBcUJMLFFBQWdCLEVBQUVYLE1BQWM7SUFDbkUsTUFBTXRCLElBQUk5RjtJQUNWLElBQUksQ0FBQzhGLEVBQUV2RSxhQUFhLEVBQUV1RSxFQUFFdkUsYUFBYSxHQUFHLElBQUlwQjtRQUM5QjJGO0lBQWQsTUFBTXVDLE9BQVF2QyxDQUFBQSwwQkFBQUEsRUFBRXhFLGdCQUFnQixDQUFDUyxHQUFHLENBQUNnRyx1QkFBdkJqQyxxQ0FBQUEsMEJBQW9DLEVBQUU7SUFDcEQsSUFBSXdDLFFBQVE7SUFDWixLQUFLLE1BQU1sRSxLQUFLaUUsS0FBTTtRQUNwQixJQUFJakUsRUFBRXNELFNBQVMsS0FBS04sUUFBUTtRQUM1QixNQUFNbUIsVUFBVXpDLEVBQUV2RSxhQUFhLENBQUNRLEdBQUcsQ0FBQ3FDLEVBQUV4QyxFQUFFO1FBQ3hDLElBQUksQ0FBQzJHLFdBQVcsQ0FBQ0EsUUFBUUMsR0FBRyxDQUFDcEIsU0FBU2tCO0lBQ3hDO0lBQ0EsT0FBT0E7QUFDVDtBQUVPLFNBQVNHLGlDQUFpQ1YsUUFBZ0IsRUFBRVgsTUFBYztJQUMvRSxNQUFNdEIsSUFBSTlGO0lBQ1YsSUFBSSxDQUFDOEYsRUFBRXZFLGFBQWEsRUFBRXVFLEVBQUV2RSxhQUFhLEdBQUcsSUFBSXBCO1FBQzlCMkY7SUFBZCxNQUFNdUMsT0FBUXZDLENBQUFBLDBCQUFBQSxFQUFFeEUsZ0JBQWdCLENBQUNTLEdBQUcsQ0FBQ2dHLHVCQUF2QmpDLHFDQUFBQSwwQkFBb0MsRUFBRTtJQUNwRCxLQUFLLE1BQU0xQixLQUFLaUUsS0FBTTtRQUNwQixJQUFJakUsRUFBRXNELFNBQVMsS0FBS04sUUFBUTtZQUNmdEI7UUFBYixNQUFNbkUsTUFBTSxDQUFDbUUsdUJBQUFBLEVBQUV2RSxhQUFhLENBQUNRLEdBQUcsQ0FBQ3FDLEVBQUV4QyxFQUFFLGVBQXhCa0Usa0NBQUFBLHVCQUF5RCxJQUFJK0I7UUFDMUVsRyxJQUFJdUcsR0FBRyxDQUFDZDtRQUNSdEIsRUFBRXZFLGFBQWEsQ0FBQ0ksR0FBRyxDQUFDeUMsRUFBRXhDLEVBQUUsRUFBRUQ7SUFDNUI7SUFDQSxPQUFPO1FBQUUwRSxJQUFJO0lBQUs7QUFDcEI7QUFFQSx3Q0FBd0M7QUFDakMsU0FBU3FDO0lBQ2QsTUFBTTVDLElBQUk5RjtJQUNWLElBQUksQ0FBQzhGLEVBQUV0RSxZQUFZLEVBQUVzRSxFQUFFdEUsWUFBWSxHQUFHLElBQUlyQjtJQUMxQyxNQUFNd0ksTUFBK0IsQ0FBQztJQUN0QyxLQUFLLE1BQU0sQ0FBQ0MsR0FBR0MsRUFBRSxJQUFJL0MsRUFBRXRFLFlBQVksQ0FBQ3lDLE9BQU8sR0FBSTBFLEdBQUcsQ0FBQ0MsRUFBRSxHQUFHLENBQUMsQ0FBQ0M7SUFDMUQsT0FBT0Y7QUFDVDtBQUVPLFNBQVNHLG1CQUFtQkMsR0FBVyxFQUFFQyxLQUFjO0lBQzVELE1BQU1sRCxJQUFJOUY7SUFDVixJQUFJLENBQUM4RixFQUFFdEUsWUFBWSxFQUFFc0UsRUFBRXRFLFlBQVksR0FBRyxJQUFJckI7SUFDMUMyRixFQUFFdEUsWUFBWSxDQUFDRyxHQUFHLENBQUNvSCxLQUFLLENBQUMsQ0FBQ0M7SUFDMUIsT0FBTztRQUFFRDtRQUFLQyxPQUFPLENBQUMsQ0FBQ0E7SUFBTTtBQUMvQjtBQUVPLFNBQVNDLDZCQUE2QmxCLFFBQWdCO0lBQzNELE1BQU1qQyxJQUFJOUY7UUFDRjhGO0lBQVIsT0FBTyxDQUFDQSxDQUFBQSw4QkFBQUEsRUFBRXpFLG9CQUFvQixDQUFDVSxHQUFHLENBQUNnRyx1QkFBM0JqQyx5Q0FBQUEsOEJBQXdDLEVBQUUsRUFBRUcsS0FBSztBQUMzRDtBQUVBLGdEQUFnRDtBQUN6QyxTQUFTaUQsb0JBQW9CdEYsR0FBa0U7SUFDcEcsTUFBTWtDLElBQUk5RjtJQUNWLElBQUksQ0FBQzhGLEVBQUVxRCxtQkFBbUIsRUFBRXJELEVBQUVxRCxtQkFBbUIsR0FBRyxJQUFJaEo7UUFDN0N5RDtJQUFYLE1BQU1oQyxLQUFLZ0MsQ0FBQUEsVUFBQUEsSUFBSWhDLEVBQUUsY0FBTmdDLHFCQUFBQSxVQUFVNkMsT0FBTztJQUM1QixNQUFNQyxhQUFhLElBQUlDLE9BQU9DLFdBQVc7UUFDd0JoRDtJQUFqRSxNQUFNK0UsTUFBTTtRQUFFL0c7UUFBSW9GLFNBQVNwRCxJQUFJb0QsT0FBTztRQUFFb0MsTUFBTXhGLElBQUl3RixJQUFJO1FBQUVDLFNBQVN6RixDQUFBQSxlQUFBQSxJQUFJeUYsT0FBTyxjQUFYekYsMEJBQUFBLGVBQWUsQ0FBQztRQUFHOEM7UUFBWWtCLFNBQVM7SUFBSztRQUNsRzlCO0lBQVosTUFBTXBELE1BQU1vRCxDQUFBQSw2QkFBQUEsRUFBRXFELG1CQUFtQixDQUFDcEgsR0FBRyxDQUFDNkIsSUFBSW9ELE9BQU8sZUFBckNsQix3Q0FBQUEsNkJBQTBDLEVBQUU7SUFDeERwRCxJQUFJcUQsT0FBTyxDQUFDNEM7SUFDWjdDLEVBQUVxRCxtQkFBbUIsQ0FBQ3hILEdBQUcsQ0FBQ2lDLElBQUlvRCxPQUFPLEVBQUV0RTtJQUN2QyxPQUFPaUc7QUFDVDtBQUVPLFNBQVNXLDRCQUE0QmxDLE1BQWM7SUFDeEQsTUFBTXRCLElBQUk5RjtJQUNWLElBQUksQ0FBQzhGLEVBQUVxRCxtQkFBbUIsRUFBRXJELEVBQUVxRCxtQkFBbUIsR0FBRyxJQUFJaEo7UUFDaEQyRjtJQUFSLE9BQU8sQ0FBQ0EsQ0FBQUEsNkJBQUFBLEVBQUVxRCxtQkFBbUIsQ0FBQ3BILEdBQUcsQ0FBQ3FGLHFCQUExQnRCLHdDQUFBQSw2QkFBcUMsRUFBRSxFQUFFRyxLQUFLO0FBQ3hEO0FBRU8sU0FBU3NELHlCQUF5QjNILEVBQVU7SUFDakQsTUFBTWtFLElBQUk5RjtJQUNWLElBQUksQ0FBQzhGLEVBQUVxRCxtQkFBbUIsRUFBRXJELEVBQUVxRCxtQkFBbUIsR0FBRyxJQUFJaEo7SUFDeEQsS0FBSyxNQUFNLENBQUMyRyxLQUFLcEUsSUFBSSxJQUFJb0QsRUFBRXFELG1CQUFtQixDQUFDbEYsT0FBTyxHQUFJO1FBQ3hELE1BQU1DLE1BQU14QixJQUFJeUIsU0FBUyxDQUFDLENBQUNxRixJQUFXQSxFQUFFNUgsRUFBRSxLQUFLQTtRQUMvQyxJQUFJc0MsT0FBTyxHQUFHO1lBQ1p4QixHQUFHLENBQUN3QixJQUFJLEdBQUc7Z0JBQUUsR0FBR3hCLEdBQUcsQ0FBQ3dCLElBQUk7Z0JBQUUwRCxTQUFTLElBQUlqQixPQUFPQyxXQUFXO1lBQUc7WUFDNURkLEVBQUVxRCxtQkFBbUIsQ0FBQ3hILEdBQUcsQ0FBQ21GLEtBQUtwRTtZQUMvQixPQUFPQSxHQUFHLENBQUN3QixJQUFJO1FBQ2pCO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTdUYsNkJBQTZCckMsTUFBYztJQUN6RCxNQUFNdEIsSUFBSTlGO0lBQ1YsSUFBSSxDQUFDOEYsRUFBRXFELG1CQUFtQixFQUFFckQsRUFBRXFELG1CQUFtQixHQUFHLElBQUloSjtRQUMzQzJGO0lBQWIsTUFBTXBELE1BQU0sQ0FBQ29ELENBQUFBLDZCQUFBQSxFQUFFcUQsbUJBQW1CLENBQUNwSCxHQUFHLENBQUNxRixxQkFBMUJ0Qix3Q0FBQUEsNkJBQXFDLEVBQUUsRUFBRXJDLEdBQUcsQ0FBQyxDQUFDK0Y7WUFBNkJBO2VBQWpCO1lBQUUsR0FBR0EsQ0FBQztZQUFFNUIsU0FBUzRCLENBQUFBLGFBQUFBLEVBQUU1QixPQUFPLGNBQVQ0Qix3QkFBQUEsYUFBYSxJQUFJN0MsT0FBT0MsV0FBVztRQUFHO0lBQUE7SUFDOUhkLEVBQUVxRCxtQkFBbUIsQ0FBQ3hILEdBQUcsQ0FBQ3lGLFFBQVExRTtJQUNsQyxPQUFPO1FBQUUyRCxJQUFJO0lBQUs7QUFDcEI7QUFJQSxNQUFNcUQsZ0JBQXVDO0lBQzNDLGtCQUFrQjtJQUNsQixxQkFBcUI7SUFDckIsZUFBZTtJQUNmLDBCQUEwQjtJQUMxQixpQkFBaUI7QUFDbkI7QUFFTyxTQUFTQywrQkFBK0J2QyxNQUFjO0lBQzNELE1BQU10QixJQUFJOUY7SUFDVixJQUFJLENBQUM4RixFQUFFOEQsdUJBQXVCLEVBQUU5RCxFQUFFOEQsdUJBQXVCLEdBQUcsSUFBSXpKO0lBQ2hFLE1BQU0wSixVQUFVL0QsRUFBRThELHVCQUF1QixDQUFDN0gsR0FBRyxDQUFDcUY7SUFDOUMsSUFBSXlDLFNBQVMsT0FBTztRQUFFLEdBQUdILGFBQWE7UUFBRSxHQUFHRyxPQUFPO0lBQUM7SUFDbkQsT0FBTztRQUFFLEdBQUdILGFBQWE7SUFBQztBQUM1QjtBQUVPLFNBQVNJLCtCQUErQjFDLE1BQWMsRUFBRTJDLE9BQThCO0lBQzNGLE1BQU1qRSxJQUFJOUY7SUFDVixJQUFJLENBQUM4RixFQUFFOEQsdUJBQXVCLEVBQUU5RCxFQUFFOEQsdUJBQXVCLEdBQUcsSUFBSXpKO0lBQ2hFLE1BQU02SixTQUFTO1FBQUUsR0FBR0wsK0JBQStCdkMsT0FBTztRQUFFLEdBQUcyQyxPQUFPO0lBQUM7SUFDdkVqRSxFQUFFOEQsdUJBQXVCLENBQUNqSSxHQUFHLENBQUN5RixRQUFRNEM7SUFDdEMsT0FBT0E7QUFDVDtBQUVPLFNBQVNDLDhCQUE4QjdDLE1BQWMsRUFBRWdDLElBQVk7SUFDeEUsTUFBTWMsUUFBUVAsK0JBQStCdkM7SUFDN0MsTUFBTStDLE1BQU1ELEtBQUssQ0FBQ2QsS0FBSztJQUN2QixPQUFPZSxRQUFRN0YsWUFBWSxPQUFPLENBQUMsQ0FBQzZGO0FBQ3RDO0FBRUEsc0JBQXNCO0FBQ2YsU0FBU0Msa0JBQWtCeEcsR0FBbUI7SUFDbkQsTUFBTWtDLElBQUk5RjtRQUNFOEY7SUFBWixNQUFNcEQsTUFBTW9ELENBQUFBLDZCQUFBQSxFQUFFbkYsbUJBQW1CLENBQUNvQixHQUFHLENBQUM2QixJQUFJakIsU0FBUyxlQUF2Q21ELHdDQUFBQSw2QkFBNEMsRUFBRTtJQUMxRHBELElBQUlFLElBQUksQ0FBQ2dCO0lBQ1RsQixJQUFJRyxJQUFJLENBQUMsQ0FBQ0MsR0FBbUJDLElBQXNCLElBQUk0RCxLQUFLNUQsRUFBRTJELFVBQVUsRUFBRTJELE9BQU8sS0FBSyxJQUFJMUQsS0FBSzdELEVBQUU0RCxVQUFVLEVBQUUyRCxPQUFPO0lBQ3BIdkUsRUFBRW5GLG1CQUFtQixDQUFDZ0IsR0FBRyxDQUFDaUMsSUFBSWpCLFNBQVMsRUFBRUQ7QUFDM0M7QUFFTyxTQUFTNEgsNEJBQTRCeEksUUFBZ0I7SUFDMUQsTUFBTWdFLElBQUk5RjtRQUNIOEY7SUFBUCxPQUFPQSxDQUFBQSw2QkFBQUEsRUFBRW5GLG1CQUFtQixDQUFDb0IsR0FBRyxDQUFDRCx1QkFBMUJnRSx3Q0FBQUEsNkJBQXVDLEVBQUU7QUFDbEQ7QUFFTyxTQUFTeUUscUJBQXFCM0ksRUFBVSxFQUFFb0MsSUFBc0U7SUFDckgsTUFBTThCLElBQUk5RjtJQUNWLEtBQUssTUFBTSxDQUFDOEIsVUFBVVksSUFBSSxJQUFJb0QsRUFBRW5GLG1CQUFtQixDQUFDc0QsT0FBTyxHQUFJO1FBQzdELE1BQU1DLE1BQU14QixJQUFJeUIsU0FBUyxDQUFDLENBQUNvQixJQUFzQkEsRUFBRTNELEVBQUUsS0FBS0E7UUFDMUQsSUFBSXNDLE9BQU8sR0FBRztZQUNaLE1BQU1rQyxPQUFPO2dCQUFFLEdBQUcxRCxHQUFHLENBQUN3QixJQUFJO2dCQUFFLEdBQUdGLElBQUk7WUFBQztZQUNwQ3RCLEdBQUcsQ0FBQ3dCLElBQUksR0FBR2tDO1lBQ1hOLEVBQUVuRixtQkFBbUIsQ0FBQ2dCLEdBQUcsQ0FBQ0csVUFBVVk7WUFDcEMsT0FBTzBEO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVPLFNBQVNvRSxxQkFBcUI1SSxFQUFVO0lBQzdDLE1BQU1rRSxJQUFJOUY7SUFDVixLQUFLLE1BQU0sQ0FBQzhCLFVBQVVZLElBQUksSUFBSW9ELEVBQUVuRixtQkFBbUIsQ0FBQ3NELE9BQU8sR0FBSTtRQUM3RCxNQUFNbUMsT0FBTzFELElBQUlMLE1BQU0sQ0FBQyxDQUFDa0QsSUFBc0JBLEVBQUUzRCxFQUFFLEtBQUtBO1FBQ3hEa0UsRUFBRW5GLG1CQUFtQixDQUFDZ0IsR0FBRyxDQUFDRyxVQUFVc0U7SUFDdEM7SUFDQSxPQUFPO1FBQUVDLElBQUk7SUFBSztBQUNwQjtBQUVBLGdDQUFnQztBQUN6QixTQUFTb0UsWUFBWUMsS0FBMEY7SUFDcEgsTUFBTTlJLEtBQUs2RSxPQUFPO0lBQ2xCLE1BQU03QyxNQUFNO1FBQUVoQztRQUFJK0ksWUFBWUQsTUFBTUMsVUFBVTtRQUFFQyxVQUFVRixNQUFNRSxRQUFRO1FBQUVDLGNBQWNILE1BQU1HLFlBQVk7UUFBRUMsYUFBYUosTUFBTUksV0FBVztRQUFFcEUsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO0lBQUc7SUFDakwsTUFBTWQsSUFBSTlGO0lBQ1Y4RixFQUFFM0UsU0FBUyxDQUFDUSxHQUFHLENBQUNDLElBQUlnQztJQUNwQixPQUFPQTtBQUNUO0FBRU8sU0FBU21ILFlBQVluSixFQUFVO0lBQ3BDLE1BQU1rRSxJQUFJOUY7UUFDSDhGO0lBQVAsT0FBT0EsQ0FBQUEsbUJBQUFBLEVBQUUzRSxTQUFTLENBQUNZLEdBQUcsQ0FBQ0gsaUJBQWhCa0UsOEJBQUFBLG1CQUF1QjtBQUNoQztBQUVBLHNCQUFzQjtBQUNmLFNBQVNrRixrQkFBa0JwSCxHQUFtQjtJQUNuRCxNQUFNa0MsSUFBSTlGO1FBQ0U4RjtJQUFaLE1BQU1wRCxNQUFNb0QsQ0FBQUEsaUNBQUFBLEVBQUVsRix1QkFBdUIsQ0FBQ21CLEdBQUcsQ0FBQzZCLElBQUlxSCxhQUFhLGVBQS9DbkYsNENBQUFBLGlDQUFvRCxFQUFFO0lBQ2xFcEQsSUFBSXFELE9BQU8sQ0FBQ25DO0lBQ1prQyxFQUFFbEYsdUJBQXVCLENBQUNlLEdBQUcsQ0FBQ2lDLElBQUlxSCxhQUFhLEVBQUV2STtBQUNuRDtBQUVPLFNBQVN3SSxnQ0FBZ0NDLFlBQW9CO0lBQ2xFLE1BQU1yRixJQUFJOUY7UUFDSDhGO0lBQVAsT0FBT0EsQ0FBQUEsaUNBQUFBLEVBQUVsRix1QkFBdUIsQ0FBQ21CLEdBQUcsQ0FBQ29KLDJCQUE5QnJGLDRDQUFBQSxpQ0FBK0MsRUFBRTtBQUMxRDtBQUVPLFNBQVNzRixvQkFBb0J4SixFQUFVLEVBQUVvQyxJQUEwQztJQUN4RixNQUFNOEIsSUFBSTlGO0lBQ1YsS0FBSyxNQUFNLENBQUNxTCxLQUFLM0ksSUFBSSxJQUFJb0QsRUFBRWxGLHVCQUF1QixDQUFDcUQsT0FBTyxHQUFJO1FBQzVELE1BQU1DLE1BQU14QixJQUFJeUIsU0FBUyxDQUFDLENBQUNvQixJQUFzQkEsRUFBRTNELEVBQUUsS0FBS0E7UUFDMUQsSUFBSXNDLE9BQU8sR0FBRztnQkFDNkNGO1lBQXpELE1BQU1vQyxPQUFPO2dCQUFFLEdBQUcxRCxHQUFHLENBQUN3QixJQUFJO2dCQUFFb0gsT0FBT3RILEtBQUtzSCxLQUFLO2dCQUFFQyxVQUFVdkgsQ0FBQUEsaUJBQUFBLEtBQUt1SCxRQUFRLGNBQWJ2SCw0QkFBQUEsaUJBQWlCO1lBQUs7WUFDL0V0QixHQUFHLENBQUN3QixJQUFJLEdBQUdrQztZQUNYTixFQUFFbEYsdUJBQXVCLENBQUNlLEdBQUcsQ0FBQzBKLEtBQUszSTtZQUNuQyxPQUFPMEQ7UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBU0EsU0FBU0ssT0FBTytFLE9BQWU7SUFDN0IsTUFBTUMsTUFBTTtJQUNaLE1BQU1DLE9BQU8sQ0FBQ2xDLElBQWN0SCxNQUFNQyxJQUFJLENBQUM7WUFBRXNDLFFBQVErRTtRQUFFLEdBQUcsSUFBTWlDLEdBQUcsQ0FBQ0UsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtKLElBQUloSCxNQUFNLEVBQUUsRUFBRXFILElBQUksQ0FBQztJQUM5RyxNQUFNQyxLQUFLTCxLQUFLO0lBQ2hCLE1BQU1NLEtBQUtOLEtBQUs7SUFDaEIsTUFBTU8sS0FBS1AsS0FBSztJQUNoQixNQUFNUSxLQUFLUixLQUFLO0lBQ2hCLE1BQU1TLEtBQUtULEtBQUs7SUFDaEIsT0FBTyxHQUFTTSxPQUFORCxJQUFHLEtBQVNFLE9BQU5ELElBQUcsS0FBU0UsT0FBTkQsSUFBRyxLQUFTRSxPQUFORCxJQUFHLEtBQU0sT0FBSEM7QUFDcEM7QUFFTyxTQUFTQyxRQUFRMUIsS0FBcUY7UUFLekZBLHVCQUNSQTtJQUxWLE1BQU05RyxNQUFnQjtRQUNwQmhDLElBQUk2RSxPQUFPO1FBQ1g5RCxXQUFXK0gsTUFBTS9ILFNBQVM7UUFDMUIwSixPQUFPM0IsTUFBTTJCLEtBQUs7UUFDbEJDLGdCQUFnQjVCLENBQUFBLHdCQUFBQSxNQUFNNEIsY0FBYyxjQUFwQjVCLG1DQUFBQSx3QkFBd0I7UUFDeEM2QixRQUFRN0IsQ0FBQUEsZ0JBQUFBLE1BQU02QixNQUFNLGNBQVo3QiwyQkFBQUEsZ0JBQWdCO1FBQ3hCaEUsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO0lBQ3BDO0lBQ0EsTUFBTWQsSUFBSTlGO1FBQ0U4RjtJQUFaLE1BQU1wRCxNQUFNb0QsQ0FBQUEseUJBQUFBLEVBQUVqRixlQUFlLENBQUNrQixHQUFHLENBQUM2QixJQUFJakIsU0FBUyxlQUFuQ21ELG9DQUFBQSx5QkFBd0MsRUFBRTtJQUN0RHBELElBQUlxRCxPQUFPLENBQUNuQztJQUNaa0MsRUFBRWpGLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDaUMsSUFBSWpCLFNBQVMsRUFBRUQ7SUFDckMsT0FBT2tCO0FBQ1Q7QUFFTyxTQUFTNEksb0JBQW9CMUssUUFBZ0I7SUFDbEQsTUFBTWdFLElBQUk5RjtRQUNGOEY7SUFBUixPQUFPLENBQUNBLENBQUFBLHlCQUFBQSxFQUFFakYsZUFBZSxDQUFDa0IsR0FBRyxDQUFDRCx1QkFBdEJnRSxvQ0FBQUEseUJBQW1DLEVBQUUsRUFBRUcsS0FBSztBQUN0RDtBQUVPLFNBQVN3RyxXQUFXN0ssRUFBVSxFQUFFb0MsSUFBa0U7SUFDdkcsTUFBTThCLElBQUk5RjtJQUNWLEtBQUssTUFBTSxDQUFDOEIsVUFBVVksSUFBSSxJQUFJb0QsRUFBRWpGLGVBQWUsQ0FBQ29ELE9BQU8sR0FBSTtRQUN6RCxNQUFNQyxNQUFNeEIsSUFBSXlCLFNBQVMsQ0FBQyxDQUFDdUksSUFBZ0JBLEVBQUU5SyxFQUFFLEtBQUtBO1FBQ3BELElBQUlzQyxPQUFPLEdBQUc7WUFDWixNQUFNd0ksSUFBSWhLLEdBQUcsQ0FBQ3dCLElBQUk7WUFDbEIsTUFBTUcsVUFBVTtnQkFBRSxHQUFHcUksQ0FBQztnQkFBRSxHQUFHMUksSUFBSTtZQUFDO1lBQ2hDdEIsR0FBRyxDQUFDd0IsSUFBSSxHQUFHRztZQUNYeUIsRUFBRWpGLGVBQWUsQ0FBQ2MsR0FBRyxDQUFDRyxVQUFVWTtZQUNoQyxPQUFPMkI7UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRU8sU0FBU3NJLFdBQVcvSyxFQUFVO0lBQ25DLE1BQU1rRSxJQUFJOUY7SUFDVixLQUFLLE1BQU0sQ0FBQzhCLFVBQVVZLElBQUksSUFBSW9ELEVBQUVqRixlQUFlLENBQUNvRCxPQUFPLEdBQUk7UUFDekQsTUFBTW1DLE9BQU8sSUFBb0IvRCxNQUFNLENBQUNxSyxDQUFBQSxJQUFLQSxFQUFFOUssRUFBRSxLQUFLQTtRQUN0RCxJQUFJd0UsS0FBSzNCLE1BQU0sS0FBSy9CLElBQUkrQixNQUFNLEVBQUU7WUFDOUJxQixFQUFFakYsZUFBZSxDQUFDYyxHQUFHLENBQUNHLFVBQVVzRTtZQUNoQywwQ0FBMEM7WUFDMUNOLEVBQUVoRixlQUFlLENBQUN1QyxNQUFNLENBQUN6QjtZQUN6QixPQUFPO2dCQUFFeUUsSUFBSTtZQUFLO1FBQ3BCO0lBQ0Y7SUFDQSxPQUFPO1FBQUVBLElBQUk7SUFBTTtBQUNyQjtBQUVPLFNBQVN1RyxZQUFZbEMsS0FBOEQ7UUFDZ0JBO0lBQXhHLE1BQU05RyxNQUF3QjtRQUFFaEMsSUFBSTZFLE9BQU87UUFBTW9HLFNBQVNuQyxNQUFNbUMsT0FBTztRQUFFQyxNQUFNcEMsTUFBTW9DLElBQUk7UUFBRTlKLGFBQWEwSCxDQUFBQSxxQkFBQUEsTUFBTTFILFdBQVcsY0FBakIwSCxnQ0FBQUEscUJBQXFCO0lBQUU7SUFDL0gsTUFBTTVFLElBQUk5RjtRQUNFOEY7SUFBWixNQUFNcEQsTUFBTW9ELENBQUFBLHlCQUFBQSxFQUFFaEYsZUFBZSxDQUFDaUIsR0FBRyxDQUFDNkIsSUFBSWlKLE9BQU8sZUFBakMvRyxvQ0FBQUEseUJBQXNDLEVBQUU7SUFDcERwRCxJQUFJRSxJQUFJLENBQUNnQjtJQUNUbEIsSUFBSUcsSUFBSSxDQUFDLENBQUNDLEdBQXFCQyxJQUF3QkQsRUFBRUUsV0FBVyxHQUFHRCxFQUFFQyxXQUFXO0lBQ3BGOEMsRUFBRWhGLGVBQWUsQ0FBQ2EsR0FBRyxDQUFDaUMsSUFBSWlKLE9BQU8sRUFBRW5LO0lBQ25DLE9BQU9rQjtBQUNUO0FBRU8sU0FBU21KLG9CQUFvQkMsTUFBYztJQUNoRCxNQUFNbEgsSUFBSTlGO1FBQ0Y4RjtJQUFSLE9BQU8sQ0FBQ0EsQ0FBQUEseUJBQUFBLEVBQUVoRixlQUFlLENBQUNpQixHQUFHLENBQUNpTCxxQkFBdEJsSCxvQ0FBQUEseUJBQWlDLEVBQUUsRUFBRUcsS0FBSztBQUNwRDtBQUVPLFNBQVNnSCxVQUFVdkMsS0FBb0Y7UUFDMEJBO0lBQXRJLE1BQU05RyxNQUFzQjtRQUFFaEMsSUFBSTZFLE9BQU87UUFBTXlHLGFBQWF4QyxNQUFNd0MsV0FBVztRQUFFSixNQUFNcEMsTUFBTW9DLElBQUk7UUFBRUssU0FBU3pDLE1BQU15QyxPQUFPO1FBQUVuSyxhQUFhMEgsQ0FBQUEscUJBQUFBLE1BQU0xSCxXQUFXLGNBQWpCMEgsZ0NBQUFBLHFCQUFxQjtJQUFFO0lBQzdKLE1BQU01RSxJQUFJOUY7UUFDRThGO0lBQVosTUFBTXBELE1BQU1vRCxDQUFBQSwyQkFBQUEsRUFBRS9FLGlCQUFpQixDQUFDZ0IsR0FBRyxDQUFDNkIsSUFBSXNKLFdBQVcsZUFBdkNwSCxzQ0FBQUEsMkJBQTRDLEVBQUU7SUFDMURwRCxJQUFJRSxJQUFJLENBQUNnQjtJQUNUbEIsSUFBSUcsSUFBSSxDQUFDLENBQUNDLEdBQW1CQyxJQUFzQkQsRUFBRUUsV0FBVyxHQUFHRCxFQUFFQyxXQUFXO0lBQ2hGOEMsRUFBRS9FLGlCQUFpQixDQUFDWSxHQUFHLENBQUNpQyxJQUFJc0osV0FBVyxFQUFFeEs7SUFDekMsT0FBT2tCO0FBQ1Q7QUFFTyxTQUFTd0osc0JBQXNCQyxVQUFrQjtJQUN0RCxNQUFNdkgsSUFBSTlGO1FBQ0Y4RjtJQUFSLE9BQU8sQ0FBQ0EsQ0FBQUEsMkJBQUFBLEVBQUUvRSxpQkFBaUIsQ0FBQ2dCLEdBQUcsQ0FBQ3NMLHlCQUF4QnZILHNDQUFBQSwyQkFBdUMsRUFBRSxFQUFFRyxLQUFLO0FBQzFEO0FBRU8sU0FBU3FILGFBQWE1QyxLQUE4QztJQUN6RSxNQUFNOUcsTUFBdUI7UUFBRWhDLElBQUk2RSxPQUFPO1FBQU1vRyxTQUFTbkMsTUFBTW1DLE9BQU87UUFBRWxJLFlBQVkrRixNQUFNL0YsVUFBVTtRQUFFNEksWUFBWSxJQUFJNUcsT0FBT0MsV0FBVztRQUFJNEcsY0FBYztRQUFNbEMsT0FBTztJQUFFO0lBQ3pLLE1BQU14RixJQUFJOUY7UUFDRThGO0lBQVosTUFBTXBELE1BQU1vRCxDQUFBQSx3QkFBQUEsRUFBRTlFLGNBQWMsQ0FBQ2UsR0FBRyxDQUFDNkIsSUFBSWlKLE9BQU8sZUFBaEMvRyxtQ0FBQUEsd0JBQXFDLEVBQUU7SUFDbkRwRCxJQUFJRSxJQUFJLENBQUNnQjtJQUNUa0MsRUFBRTlFLGNBQWMsQ0FBQ1csR0FBRyxDQUFDaUMsSUFBSWlKLE9BQU8sRUFBRW5LO0lBQ2xDLE9BQU9rQjtBQUNUO0FBRU8sU0FBUzZKLGFBQWEvQyxLQUFxRTtJQUNoRyxNQUFNNUUsSUFBSTlGO1FBQ0s4RjtJQUFmLE1BQU00SCxTQUFTNUgsQ0FBQUEsMEJBQUFBLEVBQUU3RSxnQkFBZ0IsQ0FBQ2MsR0FBRyxDQUFDMkksTUFBTWlELFVBQVUsZUFBdkM3SCxxQ0FBQUEsMEJBQTRDLEVBQUU7SUFDN0QsTUFBTTVCLE1BQU13SixPQUFPdkosU0FBUyxDQUFDLENBQUNyQixJQUFzQkEsRUFBRW9LLFdBQVcsS0FBS3hDLE1BQU13QyxXQUFXO0lBQ3ZGLE1BQU10SixNQUFzQk0sT0FBTyxJQUFJO1FBQUUsR0FBR3dKLE1BQU0sQ0FBQ3hKLElBQUk7UUFBRTBKLFdBQVdsRCxNQUFNa0QsU0FBUztRQUFFbEgsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO0lBQUcsSUFBSTtRQUM1SGhGLElBQUk2RSxPQUFPO1FBQU1rSCxZQUFZakQsTUFBTWlELFVBQVU7UUFBRVQsYUFBYXhDLE1BQU13QyxXQUFXO1FBQUVVLFdBQVdsRCxNQUFNa0QsU0FBUztRQUFFbEgsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO0lBQy9JO0lBQ0EsSUFBSTFDLE9BQU8sR0FBR3dKLE1BQU0sQ0FBQ3hKLElBQUksR0FBR047U0FBVThKLE9BQU85SyxJQUFJLENBQUNnQjtJQUNsRGtDLEVBQUU3RSxnQkFBZ0IsQ0FBQ1UsR0FBRyxDQUFDK0ksTUFBTWlELFVBQVUsRUFBRUQ7SUFDekMsT0FBTzlKO0FBQ1Q7QUFFTyxTQUFTaUssY0FBY25ELEtBQTZCO0lBQ3pELE1BQU01RSxJQUFJOUY7SUFDVixJQUFJOE47SUFDSixJQUFJZDtJQUNKLEtBQUssTUFBTSxDQUFDZSxLQUFLckwsSUFBSSxJQUFJb0QsRUFBRTlFLGNBQWMsQ0FBQ2lELE9BQU8sR0FBSTtRQUNuRCxNQUFNK0osUUFBUSxJQUEyQkMsSUFBSSxDQUFDbkwsQ0FBQUEsSUFBS0EsRUFBRWxCLEVBQUUsS0FBSzhJLE1BQU1pRCxVQUFVO1FBQzVFLElBQUlLLE9BQU87WUFBRUYsVUFBVUU7WUFBT2hCLFNBQVNlO1lBQUs7UUFBTztJQUNyRDtJQUNBLElBQUksQ0FBQ0QsV0FBVyxDQUFDZCxRQUFRLE9BQU87UUFDTWxIO0lBQXRDLE1BQU1vSSxZQUFnQ3BJLENBQUFBLHlCQUFBQSxFQUFFaEYsZUFBZSxDQUFDaUIsR0FBRyxDQUFDaUwscUJBQXRCbEgsb0NBQUFBLHlCQUFpQyxFQUFFO0lBQ3pFLE1BQU1xSSxRQUFRRCxVQUFVekosTUFBTTtRQUNJcUI7SUFBbEMsTUFBTXNJLFVBQTRCdEksQ0FBQUEsMEJBQUFBLEVBQUU3RSxnQkFBZ0IsQ0FBQ2MsR0FBRyxDQUFDK0wsUUFBUWxNLEVBQUUsZUFBakNrRSxxQ0FBQUEsMEJBQXNDLEVBQUU7SUFDMUUsSUFBSXFILFVBQVU7SUFDZCxLQUFLLE1BQU1ULEtBQUt3QixVQUFXO1FBQ3pCLE1BQU1wTCxJQUFJc0wsUUFBUUgsSUFBSSxDQUFDMUksQ0FBQUEsSUFBS0EsRUFBRTJILFdBQVcsS0FBS1IsRUFBRTlLLEVBQUU7UUFDbEQsSUFBSSxDQUFDa0IsR0FBRztZQUMwQmdEO1FBQWxDLE1BQU11SSxVQUE0QnZJLENBQUFBLDJCQUFBQSxFQUFFL0UsaUJBQWlCLENBQUNnQixHQUFHLENBQUMySyxFQUFFOUssRUFBRSxlQUE1QmtFLHNDQUFBQSwyQkFBaUMsRUFBRTtRQUNyRSxNQUFNd0ksZ0JBQWdCRCxRQUFRSixJQUFJLENBQUMzTCxDQUFBQSxJQUFLQSxFQUFFNkssT0FBTztRQUNqRCxJQUFJbUIsaUJBQWlCeEwsRUFBRThLLFNBQVMsS0FBS1UsY0FBYzFNLEVBQUUsRUFBRXVMO0lBQ3pEO0lBQ0EsSUFBSW9CLGFBQWE7SUFDakIsS0FBSyxNQUFNLEdBQUdDLFFBQVEsSUFBSTFJLEVBQUVqRixlQUFlLENBQUNvRCxPQUFPLEdBQUk7UUFDckQsTUFBTXdLLFFBQVEsUUFBd0JSLElBQUksQ0FBQyxDQUFDdkIsSUFBZ0JBLEVBQUU5SyxFQUFFLEtBQUtvTDtRQUNyRSxJQUFJeUIsT0FBTztZQUFFRixhQUFhRSxNQUFNbEMsTUFBTTtZQUFFO1FBQU87SUFDakQ7SUFDQSxNQUFNakIsUUFBUTZDLFFBQVEsSUFBSXhDLEtBQUsrQyxLQUFLLENBQUMsVUFBV1AsUUFBU0ksY0FBYztJQUN2RVQsUUFBUU4sWUFBWSxHQUFHLElBQUk3RyxPQUFPQyxXQUFXO0lBQzdDa0gsUUFBUXhDLEtBQUssR0FBR0E7SUFDaEIsT0FBT3dDO0FBQ1Q7QUFFTyxTQUFTYSxvQkFBb0I5QixPQUFlO0lBQ2pELE1BQU0vRyxJQUFJOUY7UUFDRjhGO0lBQVIsT0FBTyxDQUFDQSxDQUFBQSx3QkFBQUEsRUFBRTlFLGNBQWMsQ0FBQ2UsR0FBRyxDQUFDOEssc0JBQXJCL0csbUNBQUFBLHdCQUFpQyxFQUFFLEVBQUVHLEtBQUs7QUFDcEQ7QUFFTyxTQUFTMkkscUJBQXFCL0IsT0FBZSxFQUFFbEksVUFBa0I7SUFDdEUsTUFBTW1CLElBQUk5RjtRQUNxQjhGO0lBQS9CLE1BQU1wRCxNQUF5Qm9ELENBQUFBLHdCQUFBQSxFQUFFOUUsY0FBYyxDQUFDZSxHQUFHLENBQUM4SyxzQkFBckIvRyxtQ0FBQUEsd0JBQWlDLEVBQUU7SUFDbEUsTUFBTStJLE9BQU9uTSxJQUFJTCxNQUFNLENBQUNTLENBQUFBLElBQUtBLEVBQUU2QixVQUFVLEtBQUtBO0lBQzlDLElBQUlrSyxLQUFLcEssTUFBTSxLQUFLLEdBQUcsT0FBTztJQUM5Qm9LLEtBQUtoTSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRXdLLFVBQVUsQ0FBQ2hHLGFBQWEsQ0FBQ3pFLEVBQUV5SyxVQUFVO0lBQzNELE9BQU9zQixJQUFJLENBQUMsRUFBRTtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3Rlc3RTdG9yZS50cz9jZTNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBJbi1tZW1vcnkgdGVzdCBzdG9yZSAoZGV2L3Rlc3Qgb25seSlcclxuICpcclxuICogUHJvdmlkZXMgYSBsaWdodHdlaWdodCwgcHJvY2Vzcy1sb2NhbCBkYXRhIHN0b3JlIHVzZWQgd2hlbiBgVEVTVF9NT0RFYFxyXG4gKiBpcyBlbmFibGVkLiBJdCBzaW11bGF0ZXMgZGF0YWJhc2UgYmVoYXZpb3IgZm9yIGUyZSBhbmQgdW5pdCB0ZXN0cywgYW5kXHJcbiAqIHBlcnNpc3RzIGFjcm9zcyBOZXh0LmpzIEhNUiBieSBhdHRhY2hpbmcgdG8gYGdsb2JhbFRoaXNgLlxyXG4gKi9cclxudHlwZSBUZXN0Q291cnNlID0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbDtcclxuICB0ZWFjaGVyX2lkOiBzdHJpbmc7XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG59O1xyXG5cclxudHlwZSBUZXN0TGVzc29uID0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgY291cnNlX2lkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBjb250ZW50OiBzdHJpbmc7XHJcbiAgb3JkZXJfaW5kZXg6IG51bWJlcjtcclxuICBjcmVhdGVkX2F0OiBzdHJpbmc7XHJcbn07XHJcblxyXG50eXBlIFRlc3RNb2R1bGUgPSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBjb3Vyc2VfaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIG9yZGVyX2luZGV4OiBudW1iZXI7XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG59O1xyXG5cclxudHlwZSBUZXN0RW5yb2xsbWVudCA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHN0dWRlbnRfaWQ6IHN0cmluZztcclxuICBjb3Vyc2VfaWQ6IHN0cmluZztcclxuICBjcmVhdGVkX2F0OiBzdHJpbmc7XHJcbn07XHJcblxyXG50eXBlIFRlc3RBc3NpZ25tZW50ID0ge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgY291cnNlX2lkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgbnVsbDtcclxuICBkdWVfYXQ6IHN0cmluZyB8IG51bGw7XHJcbiAgcG9pbnRzOiBudW1iZXI7XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG59O1xyXG5cclxudHlwZSBUZXN0U3VibWlzc2lvbiA9IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIGFzc2lnbm1lbnRfaWQ6IHN0cmluZztcclxuICBzdHVkZW50X2lkOiBzdHJpbmc7XHJcbiAgdGV4dDogc3RyaW5nO1xyXG4gIGZpbGVfdXJsOiBzdHJpbmcgfCBudWxsO1xyXG4gIHN1Ym1pdHRlZF9hdDogc3RyaW5nO1xyXG4gIHNjb3JlOiBudW1iZXIgfCBudWxsO1xyXG4gIGZlZWRiYWNrOiBzdHJpbmcgfCBudWxsO1xyXG59O1xyXG5cclxudHlwZSBUZXN0UHJvZmlsZSA9IHtcclxuXHRpZDogc3RyaW5nO1xyXG5cdGVtYWlsOiBzdHJpbmc7XHJcblx0cm9sZTogXCJzdHVkZW50XCIgfCBcInRlYWNoZXJcIiB8IFwicGFyZW50XCIgfCBcImFkbWluXCI7XHJcbn07XHJcblxyXG50eXBlIFRlc3RQYXJlbnRMaW5rID0ge1xyXG5cdGlkOiBzdHJpbmc7XHJcblx0cGFyZW50X2lkOiBzdHJpbmc7XHJcblx0c3R1ZGVudF9pZDogc3RyaW5nO1xyXG5cdGNyZWF0ZWRfYXQ6IHN0cmluZztcclxufTtcclxuXHJcbi8vIFBlcnNpc3Qgc3RhdGUgYWNyb3NzIE5leHQuanMgZGV2IEhNUiBieSBhdHRhY2hpbmcgdG8gZ2xvYmFsVGhpc1xyXG5jb25zdCBnbG9iYWxTdG9yZSA9IGdsb2JhbFRoaXMgYXMgYW55O1xyXG5jb25zdCBzdGF0ZToge1xyXG4gIGNvdXJzZXM6IE1hcDxzdHJpbmcsIFRlc3RDb3Vyc2U+O1xyXG4gIGxlc3NvbnNCeUNvdXJzZTogTWFwPHN0cmluZywgVGVzdExlc3NvbltdPjtcclxuICBtb2R1bGVzQnlDb3Vyc2U6IE1hcDxzdHJpbmcsIFRlc3RNb2R1bGVbXT47XHJcbiAgZW5yb2xsbWVudHNCeVN0dWRlbnQ6IE1hcDxzdHJpbmcsIFRlc3RFbnJvbGxtZW50W10+O1xyXG4gIGVucm9sbG1lbnRzQnlDb3Vyc2U6IE1hcDxzdHJpbmcsIFRlc3RFbnJvbGxtZW50W10+O1xyXG4gIHByb2ZpbGVzQnlJZDogTWFwPHN0cmluZywgVGVzdFByb2ZpbGU+O1xyXG4gIHBhcmVudExpbmtzQnlQYXJlbnQ6IE1hcDxzdHJpbmcsIFRlc3RQYXJlbnRMaW5rW10+O1xyXG4gIC8vIEZpbGVzICh0ZXN0LW1vZGUgc3RvcmFnZSlcclxuICBmaWxlc0J5SWQ/OiBNYXA8c3RyaW5nLCB7IGlkOiBzdHJpbmc7IG93bmVyX3R5cGU6IHN0cmluZzsgb3duZXJfaWQ6IHN0cmluZzsgY29udGVudF90eXBlOiBzdHJpbmc7IGRhdGFfYmFzZTY0OiBzdHJpbmc7IGNyZWF0ZWRfYXQ6IHN0cmluZyB9PjtcclxuICBhbm5vdW5jZW1lbnRzQnlDb3Vyc2U/OiBNYXA8c3RyaW5nLCB7IGlkOiBzdHJpbmc7IGNvdXJzZV9pZDogc3RyaW5nOyB0ZWFjaGVyX2lkOiBzdHJpbmc7IHRpdGxlOiBzdHJpbmc7IGJvZHk6IHN0cmluZzsgcHVibGlzaF9hdDogc3RyaW5nIHwgbnVsbDsgY3JlYXRlZF9hdDogc3RyaW5nIH1bXT47XHJcbiAgYXNzaWdubWVudHNCeUNvdXJzZT86IE1hcDxzdHJpbmcsIFRlc3RBc3NpZ25tZW50W10+O1xyXG4gIHN1Ym1pc3Npb25zQnlBc3NpZ25tZW50PzogTWFwPHN0cmluZywgVGVzdFN1Ym1pc3Npb25bXT47XHJcbiAgcXVpenplc0J5Q291cnNlPzogTWFwPHN0cmluZywgYW55W10+O1xyXG4gIHF1ZXN0aW9uc0J5UXVpej86IE1hcDxzdHJpbmcsIGFueVtdPjtcclxuICBjaG9pY2VzQnlRdWVzdGlvbj86IE1hcDxzdHJpbmcsIGFueVtdPjtcclxuICBhdHRlbXB0c0J5UXVpej86IE1hcDxzdHJpbmcsIGFueVtdPjtcclxuICBhbnN3ZXJzQnlBdHRlbXB0PzogTWFwPHN0cmluZywgYW55W10+O1xyXG4gIC8vIE1lc3NhZ2luZ1xyXG4gIG1lc3NhZ2VUaHJlYWRzPzogeyBpZDogc3RyaW5nOyBjcmVhdGVkX2F0OiBzdHJpbmcgfVtdO1xyXG4gIHBhcnRpY2lwYW50c0J5VGhyZWFkPzogTWFwPHN0cmluZywgeyB0aHJlYWRfaWQ6IHN0cmluZzsgdXNlcl9pZDogc3RyaW5nOyByb2xlOiBzdHJpbmc7IGFkZGVkX2F0OiBzdHJpbmcgfVtdPjtcclxuICBtZXNzYWdlc0J5VGhyZWFkPzogTWFwPHN0cmluZywgeyBpZDogc3RyaW5nOyB0aHJlYWRfaWQ6IHN0cmluZzsgc2VuZGVyX2lkOiBzdHJpbmc7IGJvZHk6IHN0cmluZzsgY3JlYXRlZF9hdDogc3RyaW5nOyByZWFkX2F0OiBzdHJpbmcgfCBudWxsIH1bXT47XHJcbiAgLy8gUGVyLXVzZXIgcmVhZCByZWNlaXB0cyBmb3IgbWVzc2FnZXMgKHRlc3QtbW9kZSBvbmx5KVxyXG4gIHJlYWRCeU1lc3NhZ2U/OiBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj47XHJcbiAgLy8gRmVhdHVyZSBmbGFnc1xyXG4gIGZlYXR1cmVGbGFncz86IE1hcDxzdHJpbmcsIGJvb2xlYW4+O1xyXG59ID0gZ2xvYmFsU3RvcmUuX19URVNUX1NUT1JFX18gfHwgKGdsb2JhbFN0b3JlLl9fVEVTVF9TVE9SRV9fID0ge1xyXG4gIGNvdXJzZXM6IG5ldyBNYXA8c3RyaW5nLCBUZXN0Q291cnNlPigpLFxyXG4gIGxlc3NvbnNCeUNvdXJzZTogbmV3IE1hcDxzdHJpbmcsIFRlc3RMZXNzb25bXT4oKSxcclxuICBtb2R1bGVzQnlDb3Vyc2U6IG5ldyBNYXA8c3RyaW5nLCBUZXN0TW9kdWxlW10+KCksXHJcbiAgZW5yb2xsbWVudHNCeVN0dWRlbnQ6IG5ldyBNYXA8c3RyaW5nLCBUZXN0RW5yb2xsbWVudFtdPigpLFxyXG4gIGVucm9sbG1lbnRzQnlDb3Vyc2U6IG5ldyBNYXA8c3RyaW5nLCBUZXN0RW5yb2xsbWVudFtdPigpLFxyXG4gIHByb2ZpbGVzQnlJZDogbmV3IE1hcDxzdHJpbmcsIFRlc3RQcm9maWxlPigpLFxyXG4gIHBhcmVudExpbmtzQnlQYXJlbnQ6IG5ldyBNYXA8c3RyaW5nLCBUZXN0UGFyZW50TGlua1tdPigpXHJcbn0pO1xyXG5cclxuLy8gQmFja2ZpbGwgbWFwcyBpZiB0aGlzIG1vZHVsZSBsb2FkZWQgYWZ0ZXIgYW4gb2xkZXIgc3RvcmUgc2hhcGUgd2FzIGNyZWF0ZWQgKEhNUiBkdXJpbmcgZGV2KVxyXG5jb25zdCBhbnlTdGF0ZSA9IHN0YXRlIGFzIGFueTtcclxuaWYgKCFhbnlTdGF0ZS5wcm9maWxlc0J5SWQpIGFueVN0YXRlLnByb2ZpbGVzQnlJZCA9IG5ldyBNYXA8c3RyaW5nLCBUZXN0UHJvZmlsZT4oKTtcclxuaWYgKCFhbnlTdGF0ZS5wYXJlbnRMaW5rc0J5UGFyZW50KSBhbnlTdGF0ZS5wYXJlbnRMaW5rc0J5UGFyZW50ID0gbmV3IE1hcDxzdHJpbmcsIFRlc3RQYXJlbnRMaW5rW10+KCk7XHJcbmlmICghYW55U3RhdGUubW9kdWxlc0J5Q291cnNlKSBhbnlTdGF0ZS5tb2R1bGVzQnlDb3Vyc2UgPSBuZXcgTWFwPHN0cmluZywgVGVzdE1vZHVsZVtdPigpO1xyXG5pZiAoIWFueVN0YXRlLmFzc2lnbm1lbnRzQnlDb3Vyc2UpIGFueVN0YXRlLmFzc2lnbm1lbnRzQnlDb3Vyc2UgPSBuZXcgTWFwPHN0cmluZywgVGVzdEFzc2lnbm1lbnRbXT4oKTtcclxuaWYgKCFhbnlTdGF0ZS5zdWJtaXNzaW9uc0J5QXNzaWdubWVudCkgYW55U3RhdGUuc3VibWlzc2lvbnNCeUFzc2lnbm1lbnQgPSBuZXcgTWFwPHN0cmluZywgVGVzdFN1Ym1pc3Npb25bXT4oKTtcclxuLy8gUXVpenplcyBzdG9yZSBtYXBzIChiYWNrZmlsbCBpZiBtaXNzaW5nIGZvciBITVIpXHJcbmlmICghYW55U3RhdGUucXVpenplc0J5Q291cnNlKSBhbnlTdGF0ZS5xdWl6emVzQnlDb3Vyc2UgPSBuZXcgTWFwPHN0cmluZywgYW55W10+KCk7XHJcbmlmICghYW55U3RhdGUucXVlc3Rpb25zQnlRdWl6KSBhbnlTdGF0ZS5xdWVzdGlvbnNCeVF1aXogPSBuZXcgTWFwPHN0cmluZywgYW55W10+KCk7XHJcbmlmICghYW55U3RhdGUuY2hvaWNlc0J5UXVlc3Rpb24pIGFueVN0YXRlLmNob2ljZXNCeVF1ZXN0aW9uID0gbmV3IE1hcDxzdHJpbmcsIGFueVtdPigpO1xyXG5pZiAoIWFueVN0YXRlLmF0dGVtcHRzQnlRdWl6KSBhbnlTdGF0ZS5hdHRlbXB0c0J5UXVpeiA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKTtcclxuaWYgKCFhbnlTdGF0ZS5hbnN3ZXJzQnlBdHRlbXB0KSBhbnlTdGF0ZS5hbnN3ZXJzQnlBdHRlbXB0ID0gbmV3IE1hcDxzdHJpbmcsIGFueVtdPigpO1xyXG5pZiAoIWFueVN0YXRlLmFubm91bmNlbWVudHNCeUNvdXJzZSkgYW55U3RhdGUuYW5ub3VuY2VtZW50c0J5Q291cnNlID0gbmV3IE1hcDxzdHJpbmcsIGFueVtdPigpO1xyXG5pZiAoIWFueVN0YXRlLmZpbGVzQnlJZCkgYW55U3RhdGUuZmlsZXNCeUlkID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcclxuLy8gTWVzc2FnaW5nIG1hcHNcclxuaWYgKCFhbnlTdGF0ZS5tZXNzYWdlVGhyZWFkcykgYW55U3RhdGUubWVzc2FnZVRocmVhZHMgPSBbXTtcclxuaWYgKCFhbnlTdGF0ZS5wYXJ0aWNpcGFudHNCeVRocmVhZCkgYW55U3RhdGUucGFydGljaXBhbnRzQnlUaHJlYWQgPSBuZXcgTWFwPHN0cmluZywgYW55W10+KCk7XHJcbmlmICghYW55U3RhdGUubWVzc2FnZXNCeVRocmVhZCkgYW55U3RhdGUubWVzc2FnZXNCeVRocmVhZCA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKTtcclxuaWYgKCFhbnlTdGF0ZS5yZWFkQnlNZXNzYWdlKSBhbnlTdGF0ZS5yZWFkQnlNZXNzYWdlID0gbmV3IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PigpO1xyXG5pZiAoIWFueVN0YXRlLmZlYXR1cmVGbGFncykgYW55U3RhdGUuZmVhdHVyZUZsYWdzID0gbmV3IE1hcDxzdHJpbmcsIGJvb2xlYW4+KCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkVGVzdENvdXJzZShjb3Vyc2U6IFRlc3RDb3Vyc2UpIHtcclxuICBzdGF0ZS5jb3Vyc2VzLnNldChjb3Vyc2UuaWQsIGNvdXJzZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXN0Q291cnNlKGNvdXJzZUlkOiBzdHJpbmcpOiBUZXN0Q291cnNlIHwgdW5kZWZpbmVkIHtcclxuICByZXR1cm4gc3RhdGUuY291cnNlcy5nZXQoY291cnNlSWQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGlzdFRlc3RDb3Vyc2VzQnlUZWFjaGVyKHRlYWNoZXJJZDogc3RyaW5nKTogVGVzdENvdXJzZVtdIHtcclxuICByZXR1cm4gQXJyYXkuZnJvbShzdGF0ZS5jb3Vyc2VzLnZhbHVlcygpKS5maWx0ZXIoYyA9PiBjLnRlYWNoZXJfaWQgPT09IHRlYWNoZXJJZCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRUZXN0TGVzc29uKGxlc3NvbjogVGVzdExlc3Nvbikge1xyXG4gIGNvbnN0IGFyciA9IHN0YXRlLmxlc3NvbnNCeUNvdXJzZS5nZXQobGVzc29uLmNvdXJzZV9pZCkgPz8gW107XHJcbiAgYXJyLnB1c2gobGVzc29uKTtcclxuICBhcnIuc29ydCgoYSwgYikgPT4gYS5vcmRlcl9pbmRleCAtIGIub3JkZXJfaW5kZXgpO1xyXG4gIHN0YXRlLmxlc3NvbnNCeUNvdXJzZS5zZXQobGVzc29uLmNvdXJzZV9pZCwgYXJyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0TGVzc29uc0J5Q291cnNlKGNvdXJzZUlkOiBzdHJpbmcpOiBUZXN0TGVzc29uW10ge1xyXG4gIHJldHVybiBzdGF0ZS5sZXNzb25zQnlDb3Vyc2UuZ2V0KGNvdXJzZUlkKSA/PyBbXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0VGVzdFN0b3JlKCkge1xyXG4gIHN0YXRlLmNvdXJzZXMuY2xlYXIoKTtcclxuICBzdGF0ZS5sZXNzb25zQnlDb3Vyc2UuY2xlYXIoKTtcclxuICBzdGF0ZS5tb2R1bGVzQnlDb3Vyc2UuY2xlYXIoKTtcclxuICBzdGF0ZS5lbnJvbGxtZW50c0J5U3R1ZGVudC5jbGVhcigpO1xyXG4gIHN0YXRlLmVucm9sbG1lbnRzQnlDb3Vyc2UuY2xlYXIoKTtcclxuICBzdGF0ZS5wYXJlbnRMaW5rc0J5UGFyZW50LmNsZWFyKCk7XHJcbiAgKHN0YXRlIGFzIGFueSkuYXNzaWdubWVudHNCeUNvdXJzZT8uY2xlYXI/LigpO1xyXG4gIChzdGF0ZSBhcyBhbnkpLnN1Ym1pc3Npb25zQnlBc3NpZ25tZW50Py5jbGVhcj8uKCk7XHJcbiAgLy8gUXVpenplc1xyXG4gIChzdGF0ZSBhcyBhbnkpLnF1aXp6ZXNCeUNvdXJzZT8uY2xlYXI/LigpO1xyXG4gIChzdGF0ZSBhcyBhbnkpLnF1ZXN0aW9uc0J5UXVpej8uY2xlYXI/LigpO1xyXG4gIChzdGF0ZSBhcyBhbnkpLmNob2ljZXNCeVF1ZXN0aW9uPy5jbGVhcj8uKCk7XHJcbiAgKHN0YXRlIGFzIGFueSkuYXR0ZW1wdHNCeVF1aXo/LmNsZWFyPy4oKTtcclxuICAoc3RhdGUgYXMgYW55KS5hbnN3ZXJzQnlBdHRlbXB0Py5jbGVhcj8uKCk7XHJcbiAgKHN0YXRlIGFzIGFueSkuYW5ub3VuY2VtZW50c0J5Q291cnNlPy5jbGVhcj8uKCk7XHJcbiAgKHN0YXRlIGFzIGFueSkubWVzc2FnZVRocmVhZHMgPSBbXTtcclxuICAoc3RhdGUgYXMgYW55KS5wYXJ0aWNpcGFudHNCeVRocmVhZD8uY2xlYXI/LigpO1xyXG4gIChzdGF0ZSBhcyBhbnkpLm1lc3NhZ2VzQnlUaHJlYWQ/LmNsZWFyPy4oKTtcclxuICAoc3RhdGUgYXMgYW55KS5maWxlc0J5SWQ/LmNsZWFyPy4oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVRlc3RDb3Vyc2UoY291cnNlSWQ6IHN0cmluZykge1xyXG4gIHN0YXRlLmNvdXJzZXMuZGVsZXRlKGNvdXJzZUlkKTtcclxuICBzdGF0ZS5sZXNzb25zQnlDb3Vyc2UuZGVsZXRlKGNvdXJzZUlkKTtcclxuICAvLyBOb3RlOiB3ZSBpbnRlbnRpb25hbGx5IGRvIG5vdCBjbGVhciBlbnJvbGxtZW50cyB0byBrZWVwIGhpc3RvcnkgdW5sZXNzIG5lZWRlZFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVvcmRlclRlc3RMZXNzb25zKGNvdXJzZUlkOiBzdHJpbmcsIHVwZGF0ZXM6IHsgaWQ6IHN0cmluZzsgb3JkZXJfaW5kZXg6IG51bWJlciB9W10pIHtcclxuICBjb25zdCBhcnIgPSBzdGF0ZS5sZXNzb25zQnlDb3Vyc2UuZ2V0KGNvdXJzZUlkKSA/PyBbXTtcclxuICBjb25zdCBieUlkID0gbmV3IE1hcChhcnIubWFwKGwgPT4gW2wuaWQsIGxdIGFzIGNvbnN0KSk7XHJcbiAgZm9yIChjb25zdCB1IG9mIHVwZGF0ZXMpIHtcclxuICAgIGNvbnN0IHJvdyA9IGJ5SWQuZ2V0KHUuaWQpO1xyXG4gICAgaWYgKHJvdykgcm93Lm9yZGVyX2luZGV4ID0gdS5vcmRlcl9pbmRleDtcclxuICB9XHJcbiAgYXJyLnNvcnQoKGEsIGIpID0+IGEub3JkZXJfaW5kZXggLSBiLm9yZGVyX2luZGV4KTtcclxuICBzdGF0ZS5sZXNzb25zQnlDb3Vyc2Uuc2V0KGNvdXJzZUlkLCBhcnIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkVGVzdE1vZHVsZShyb3c6IFRlc3RNb2R1bGUpIHtcclxuICBjb25zdCBhcnIgPSBzdGF0ZS5tb2R1bGVzQnlDb3Vyc2UuZ2V0KHJvdy5jb3Vyc2VfaWQpID8/IFtdO1xyXG4gIGFyci5wdXNoKHJvdyk7XHJcbiAgYXJyLnNvcnQoKGEsIGIpID0+IGEub3JkZXJfaW5kZXggLSBiLm9yZGVyX2luZGV4KTtcclxuICBzdGF0ZS5tb2R1bGVzQnlDb3Vyc2Uuc2V0KHJvdy5jb3Vyc2VfaWQsIGFycik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0VGVzdE1vZHVsZXNCeUNvdXJzZShjb3Vyc2VJZDogc3RyaW5nKTogVGVzdE1vZHVsZVtdIHtcclxuICByZXR1cm4gc3RhdGUubW9kdWxlc0J5Q291cnNlLmdldChjb3Vyc2VJZCkgPz8gW107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUZXN0TW9kdWxlKGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8UGljazxUZXN0TW9kdWxlLCAndGl0bGUnIHwgJ29yZGVyX2luZGV4Jz4+KSB7XHJcbiAgZm9yIChjb25zdCBbY291cnNlSWQsIGFycl0gb2Ygc3RhdGUubW9kdWxlc0J5Q291cnNlLmVudHJpZXMoKSkge1xyXG4gICAgY29uc3QgaWR4ID0gYXJyLmZpbmRJbmRleChtID0+IG0uaWQgPT09IGlkKTtcclxuICAgIGlmIChpZHggPj0gMCkge1xyXG4gICAgICBjb25zdCB1cGRhdGVkID0geyAuLi5hcnJbaWR4XSwgLi4uZGF0YSB9IGFzIFRlc3RNb2R1bGU7XHJcbiAgICAgIGFycltpZHhdID0gdXBkYXRlZDtcclxuICAgICAgYXJyLnNvcnQoKGEsIGIpID0+IGEub3JkZXJfaW5kZXggLSBiLm9yZGVyX2luZGV4KTtcclxuICAgICAgc3RhdGUubW9kdWxlc0J5Q291cnNlLnNldChjb3Vyc2VJZCwgYXJyKTtcclxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVUZXN0TW9kdWxlKGlkOiBzdHJpbmcpIHtcclxuICBmb3IgKGNvbnN0IFtjb3Vyc2VJZCwgYXJyXSBvZiBzdGF0ZS5tb2R1bGVzQnlDb3Vyc2UuZW50cmllcygpKSB7XHJcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGFyci5maWx0ZXIobSA9PiBtLmlkICE9PSBpZCk7XHJcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoICE9PSBhcnIubGVuZ3RoKSB7XHJcbiAgICAgIHN0YXRlLm1vZHVsZXNCeUNvdXJzZS5zZXQoY291cnNlSWQsIGZpbHRlcmVkKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkVGVzdEVucm9sbG1lbnQocm93OiBUZXN0RW5yb2xsbWVudCkge1xyXG4gIGNvbnN0IGEgPSBzdGF0ZS5lbnJvbGxtZW50c0J5U3R1ZGVudC5nZXQocm93LnN0dWRlbnRfaWQpID8/IFtdO1xyXG4gIGEucHVzaChyb3cpO1xyXG4gIHN0YXRlLmVucm9sbG1lbnRzQnlTdHVkZW50LnNldChyb3cuc3R1ZGVudF9pZCwgYSk7XHJcbiAgY29uc3QgYiA9IHN0YXRlLmVucm9sbG1lbnRzQnlDb3Vyc2UuZ2V0KHJvdy5jb3Vyc2VfaWQpID8/IFtdO1xyXG4gIGIucHVzaChyb3cpO1xyXG4gIHN0YXRlLmVucm9sbG1lbnRzQnlDb3Vyc2Uuc2V0KHJvdy5jb3Vyc2VfaWQsIGIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGlzdFRlc3RFbnJvbGxtZW50c0J5U3R1ZGVudChzdHVkZW50SWQ6IHN0cmluZyk6IFRlc3RFbnJvbGxtZW50W10ge1xyXG4gIHJldHVybiBzdGF0ZS5lbnJvbGxtZW50c0J5U3R1ZGVudC5nZXQoc3R1ZGVudElkKSA/PyBbXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0RW5yb2xsbWVudHNCeUNvdXJzZShjb3Vyc2VJZDogc3RyaW5nKTogVGVzdEVucm9sbG1lbnRbXSB7XHJcbiAgcmV0dXJuIHN0YXRlLmVucm9sbG1lbnRzQnlDb3Vyc2UuZ2V0KGNvdXJzZUlkKSA/PyBbXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVwc2VydFRlc3RQcm9maWxlKHByb2ZpbGU6IFRlc3RQcm9maWxlKSB7XHJcblx0c3RhdGUucHJvZmlsZXNCeUlkLnNldChwcm9maWxlLmlkLCBwcm9maWxlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRlc3RQcm9maWxlKGlkOiBzdHJpbmcpOiBUZXN0UHJvZmlsZSB8IHVuZGVmaW5lZCB7XHJcblx0cmV0dXJuIHN0YXRlLnByb2ZpbGVzQnlJZC5nZXQoaWQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkVGVzdFBhcmVudExpbmsocm93OiBUZXN0UGFyZW50TGluaykge1xyXG5cdGNvbnN0IGEgPSBzdGF0ZS5wYXJlbnRMaW5rc0J5UGFyZW50LmdldChyb3cucGFyZW50X2lkKSA/PyBbXTtcclxuXHRhLnB1c2gocm93KTtcclxuXHRzdGF0ZS5wYXJlbnRMaW5rc0J5UGFyZW50LnNldChyb3cucGFyZW50X2lkLCBhKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0UGFyZW50Q2hpbGRyZW4ocGFyZW50SWQ6IHN0cmluZyk6IFRlc3RQYXJlbnRMaW5rW10ge1xyXG5cdHJldHVybiBzdGF0ZS5wYXJlbnRMaW5rc0J5UGFyZW50LmdldChwYXJlbnRJZCkgPz8gW107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVUZXN0UGFyZW50TGluayhwYXJlbnRJZDogc3RyaW5nLCBzdHVkZW50SWQ6IHN0cmluZykge1xyXG5cdGNvbnN0IGEgPSBzdGF0ZS5wYXJlbnRMaW5rc0J5UGFyZW50LmdldChwYXJlbnRJZCkgPz8gW107XHJcblx0Y29uc3QgYiA9IGEuZmlsdGVyKHggPT4geC5zdHVkZW50X2lkICE9PSBzdHVkZW50SWQpO1xyXG5cdHN0YXRlLnBhcmVudExpbmtzQnlQYXJlbnQuc2V0KHBhcmVudElkLCBiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0UGFyZW50c0ZvclN0dWRlbnQoc3R1ZGVudElkOiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcblx0Y29uc3QgcmVzOiBzdHJpbmdbXSA9IFtdO1xyXG5cdGZvciAoY29uc3QgW3BpZCwgYXJyXSBvZiBzdGF0ZS5wYXJlbnRMaW5rc0J5UGFyZW50LmVudHJpZXMoKSkge1xyXG5cdFx0aWYgKChhcnIgPz8gW10pLnNvbWUocGwgPT4gcGwuc3R1ZGVudF9pZCA9PT0gc3R1ZGVudElkKSkgcmVzLnB1c2gocGlkKTtcclxuXHR9XHJcblx0cmV0dXJuIHJlcztcclxufVxyXG5cclxuLy8gQW5ub3VuY2VtZW50cyBoZWxwZXJzICh0ZXN0LW1vZGUpXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRUZXN0QW5ub3VuY2VtZW50KHJvdzogeyBpZDogc3RyaW5nOyBjb3Vyc2VfaWQ6IHN0cmluZzsgdGVhY2hlcl9pZDogc3RyaW5nOyB0aXRsZTogc3RyaW5nOyBib2R5OiBzdHJpbmc7IHB1Ymxpc2hfYXQ6IHN0cmluZyB8IG51bGw7IGNyZWF0ZWRfYXQ6IHN0cmluZyB9KSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBjb25zdCBhcnIgPSBzLmFubm91bmNlbWVudHNCeUNvdXJzZS5nZXQocm93LmNvdXJzZV9pZCkgPz8gW107XHJcbiAgYXJyLnVuc2hpZnQocm93KTtcclxuICBzLmFubm91bmNlbWVudHNCeUNvdXJzZS5zZXQocm93LmNvdXJzZV9pZCwgYXJyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0QW5ub3VuY2VtZW50c0J5Q291cnNlKGNvdXJzZUlkOiBzdHJpbmcpIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIHJldHVybiAocy5hbm5vdW5jZW1lbnRzQnlDb3Vyc2UuZ2V0KGNvdXJzZUlkKSA/PyBbXSkuc2xpY2UoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVRlc3RBbm5vdW5jZW1lbnQoaWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgZm9yIChjb25zdCBbY2lkLCBhcnJdIG9mIHMuYW5ub3VuY2VtZW50c0J5Q291cnNlLmVudHJpZXMoKSkge1xyXG4gICAgY29uc3QgbmV4dCA9IGFyci5maWx0ZXIoKHg6IGFueSkgPT4geC5pZCAhPT0gaWQpO1xyXG4gICAgaWYgKG5leHQubGVuZ3RoICE9PSBhcnIubGVuZ3RoKSB7XHJcbiAgICAgIHMuYW5ub3VuY2VtZW50c0J5Q291cnNlLnNldChjaWQsIG5leHQpO1xyXG4gICAgICByZXR1cm4geyBvazogdHJ1ZSB9IGFzIGNvbnN0O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4geyBvazogZmFsc2UgfSBhcyBjb25zdDtcclxufVxyXG5cclxuLy8gPT09PT0gTWVzc2FnaW5nIGhlbHBlcnMgKHRlc3QtbW9kZSkgPT09PT1cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRlc3RUaHJlYWQocGFydGljaXBhbnRJZHM6IHN0cmluZ1tdLCByb2xlcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pIHtcclxuICBjb25zdCBpZCA9IG1ha2VJZCgndGgnKTtcclxuICBjb25zdCBjcmVhdGVkX2F0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgcy5tZXNzYWdlVGhyZWFkcy5wdXNoKHsgaWQsIGNyZWF0ZWRfYXQgfSk7XHJcbiAgY29uc3QgcGFydHMgPSBwYXJ0aWNpcGFudElkcy5tYXAodWlkID0+ICh7IHRocmVhZF9pZDogaWQsIHVzZXJfaWQ6IHVpZCwgcm9sZTogcm9sZXM/Llt1aWRdID8/ICd1c2VyJywgYWRkZWRfYXQ6IGNyZWF0ZWRfYXQgfSkpO1xyXG4gIHMucGFydGljaXBhbnRzQnlUaHJlYWQuc2V0KGlkLCBwYXJ0cyk7XHJcbiAgcmV0dXJuIHsgaWQsIGNyZWF0ZWRfYXQgfSBhcyBjb25zdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0VGhyZWFkc0J5VXNlcih1c2VySWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgY29uc3QgcmVzOiB7IGlkOiBzdHJpbmc7IGNyZWF0ZWRfYXQ6IHN0cmluZyB9W10gPSBbXTtcclxuICBmb3IgKGNvbnN0IHQgb2Ygcy5tZXNzYWdlVGhyZWFkcyBhcyB7IGlkOiBzdHJpbmc7IGNyZWF0ZWRfYXQ6IHN0cmluZyB9W10pIHtcclxuICAgIGNvbnN0IHBhcnRzID0gKHMucGFydGljaXBhbnRzQnlUaHJlYWQuZ2V0KHQuaWQpID8/IFtdKSBhcyBhbnlbXTtcclxuICAgIGlmIChwYXJ0cy5zb21lKHAgPT4gcC51c2VyX2lkID09PSB1c2VySWQpKSByZXMucHVzaCh0KTtcclxuICB9XHJcbiAgLy8gbmV3ZXN0IGZpcnN0XHJcbiAgcmVzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdC5sb2NhbGVDb21wYXJlKGEuY3JlYXRlZF9hdCkpO1xyXG4gIHJldHVybiByZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRUZXN0TWVzc2FnZShyb3c6IHsgdGhyZWFkX2lkOiBzdHJpbmc7IHNlbmRlcl9pZDogc3RyaW5nOyBib2R5OiBzdHJpbmcgfSkge1xyXG4gIGNvbnN0IGlkID0gbWFrZUlkKCdtcycpO1xyXG4gIGNvbnN0IGNyZWF0ZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgY29uc3QgbXNnID0geyBpZCwgdGhyZWFkX2lkOiByb3cudGhyZWFkX2lkLCBzZW5kZXJfaWQ6IHJvdy5zZW5kZXJfaWQsIGJvZHk6IHJvdy5ib2R5LCBjcmVhdGVkX2F0LCByZWFkX2F0OiBudWxsIH07XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBjb25zdCBhcnIgPSBzLm1lc3NhZ2VzQnlUaHJlYWQuZ2V0KHJvdy50aHJlYWRfaWQpID8/IFtdO1xyXG4gIGFyci5wdXNoKG1zZyk7XHJcbiAgYXJyLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBhLmNyZWF0ZWRfYXQubG9jYWxlQ29tcGFyZShiLmNyZWF0ZWRfYXQpKTtcclxuICBzLm1lc3NhZ2VzQnlUaHJlYWQuc2V0KHJvdy50aHJlYWRfaWQsIGFycik7XHJcbiAgLy8gSW5pdGlhbGl6ZSByZWFkIHJlY2VpcHRzIG1hcFxyXG4gIGlmICghcy5yZWFkQnlNZXNzYWdlKSBzLnJlYWRCeU1lc3NhZ2UgPSBuZXcgTWFwPHN0cmluZywgU2V0PHN0cmluZz4+KCk7XHJcbiAgcy5yZWFkQnlNZXNzYWdlLnNldChpZCwgbmV3IFNldDxzdHJpbmc+KCkpO1xyXG4gIHJldHVybiBtc2c7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0VGVzdE1lc3NhZ2VzQnlUaHJlYWQodGhyZWFkSWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgcmV0dXJuIChzLm1lc3NhZ2VzQnlUaHJlYWQuZ2V0KHRocmVhZElkKSA/PyBbXSkuc2xpY2UoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtUZXN0TWVzc2FnZVJlYWRGb3JVc2VyKG1lc3NhZ2VJZDogc3RyaW5nLCB1c2VySWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgaWYgKCFzLnJlYWRCeU1lc3NhZ2UpIHMucmVhZEJ5TWVzc2FnZSA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8c3RyaW5nPj4oKTtcclxuICBjb25zdCBzZXQgPSBzLnJlYWRCeU1lc3NhZ2UuZ2V0KG1lc3NhZ2VJZCkgPz8gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgc2V0LmFkZCh1c2VySWQpO1xyXG4gIHMucmVhZEJ5TWVzc2FnZS5zZXQobWVzc2FnZUlkLCBzZXQpO1xyXG4gIC8vIEtlZXAgbGVnYWN5IHJlYWRfYXQgZm9yIGJhc2ljIFVJc1xyXG4gIGZvciAoY29uc3QgW3RpZCwgYXJyXSBvZiBzLm1lc3NhZ2VzQnlUaHJlYWQuZW50cmllcygpKSB7XHJcbiAgICBjb25zdCBpZHggPSBhcnIuZmluZEluZGV4KChtOiBhbnkpID0+IG0uaWQgPT09IG1lc3NhZ2VJZCk7XHJcbiAgICBpZiAoaWR4ID49IDApIHtcclxuICAgICAgaWYgKCFhcnJbaWR4XS5yZWFkX2F0KSBhcnJbaWR4XSA9IHsgLi4uYXJyW2lkeF0sIHJlYWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9O1xyXG4gICAgICBzLm1lc3NhZ2VzQnlUaHJlYWQuc2V0KHRpZCwgYXJyKTtcclxuICAgICAgcmV0dXJuIGFycltpZHhdO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50VW5yZWFkRm9yVGhyZWFkKHRocmVhZElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKTogbnVtYmVyIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIGlmICghcy5yZWFkQnlNZXNzYWdlKSBzLnJlYWRCeU1lc3NhZ2UgPSBuZXcgTWFwPHN0cmluZywgU2V0PHN0cmluZz4+KCk7XHJcbiAgY29uc3QgbXNncyA9IChzLm1lc3NhZ2VzQnlUaHJlYWQuZ2V0KHRocmVhZElkKSA/PyBbXSkgYXMgYW55W107XHJcbiAgbGV0IGNvdW50ID0gMDtcclxuICBmb3IgKGNvbnN0IG0gb2YgbXNncykge1xyXG4gICAgaWYgKG0uc2VuZGVyX2lkID09PSB1c2VySWQpIGNvbnRpbnVlO1xyXG4gICAgY29uc3QgcmVhZFNldCA9IHMucmVhZEJ5TWVzc2FnZS5nZXQobS5pZCkgYXMgU2V0PHN0cmluZz4gfCB1bmRlZmluZWQ7XHJcbiAgICBpZiAoIXJlYWRTZXQgfHwgIXJlYWRTZXQuaGFzKHVzZXJJZCkpIGNvdW50Kys7XHJcbiAgfVxyXG4gIHJldHVybiBjb3VudDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtBbGxUaHJlYWRNZXNzYWdlc1JlYWRGb3JVc2VyKHRocmVhZElkOiBzdHJpbmcsIHVzZXJJZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBpZiAoIXMucmVhZEJ5TWVzc2FnZSkgcy5yZWFkQnlNZXNzYWdlID0gbmV3IE1hcDxzdHJpbmcsIFNldDxzdHJpbmc+PigpO1xyXG4gIGNvbnN0IG1zZ3MgPSAocy5tZXNzYWdlc0J5VGhyZWFkLmdldCh0aHJlYWRJZCkgPz8gW10pIGFzIGFueVtdO1xyXG4gIGZvciAoY29uc3QgbSBvZiBtc2dzKSB7XHJcbiAgICBpZiAobS5zZW5kZXJfaWQgPT09IHVzZXJJZCkgY29udGludWU7XHJcbiAgICBjb25zdCBzZXQgPSAocy5yZWFkQnlNZXNzYWdlLmdldChtLmlkKSBhcyBTZXQ8c3RyaW5nPiB8IHVuZGVmaW5lZCkgPz8gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICBzZXQuYWRkKHVzZXJJZCk7XHJcbiAgICBzLnJlYWRCeU1lc3NhZ2Uuc2V0KG0uaWQsIHNldCk7XHJcbiAgfVxyXG4gIHJldHVybiB7IG9rOiB0cnVlIH0gYXMgY29uc3Q7XHJcbn1cclxuXHJcbi8vID09PT09IEZlYXR1cmUgRmxhZ3MgKHRlc3QtbW9kZSkgPT09PT1cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0RmVhdHVyZUZsYWdzKCk6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+IHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIGlmICghcy5mZWF0dXJlRmxhZ3MpIHMuZmVhdHVyZUZsYWdzID0gbmV3IE1hcDxzdHJpbmcsIGJvb2xlYW4+KCk7XHJcbiAgY29uc3Qgb2JqOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xyXG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIHMuZmVhdHVyZUZsYWdzLmVudHJpZXMoKSkgb2JqW2tdID0gISF2O1xyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRUZXN0RmVhdHVyZUZsYWcoa2V5OiBzdHJpbmcsIHZhbHVlOiBib29sZWFuKSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBpZiAoIXMuZmVhdHVyZUZsYWdzKSBzLmZlYXR1cmVGbGFncyA9IG5ldyBNYXA8c3RyaW5nLCBib29sZWFuPigpO1xyXG4gIHMuZmVhdHVyZUZsYWdzLnNldChrZXksICEhdmFsdWUpO1xyXG4gIHJldHVybiB7IGtleSwgdmFsdWU6ICEhdmFsdWUgfSBhcyBjb25zdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0UGFydGljaXBhbnRzQnlUaHJlYWQodGhyZWFkSWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgcmV0dXJuIChzLnBhcnRpY2lwYW50c0J5VGhyZWFkLmdldCh0aHJlYWRJZCkgPz8gW10pLnNsaWNlKCk7XHJcbn1cclxuXHJcbi8vID09PT09IE5vdGlmaWNhdGlvbnMgaGVscGVycyAodGVzdC1tb2RlKSA9PT09PVxyXG5leHBvcnQgZnVuY3Rpb24gYWRkVGVzdE5vdGlmaWNhdGlvbihyb3c6IHsgaWQ/OiBzdHJpbmc7IHVzZXJfaWQ6IHN0cmluZzsgdHlwZTogc3RyaW5nOyBwYXlsb2FkPzogYW55IH0pIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIGlmICghcy5ub3RpZmljYXRpb25zQnlVc2VyKSBzLm5vdGlmaWNhdGlvbnNCeVVzZXIgPSBuZXcgTWFwPHN0cmluZywgYW55W10+KCk7XHJcbiAgY29uc3QgaWQgPSByb3cuaWQgPz8gbWFrZUlkKCdubycpO1xyXG4gIGNvbnN0IGNyZWF0ZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgY29uc3Qgb2JqID0geyBpZCwgdXNlcl9pZDogcm93LnVzZXJfaWQsIHR5cGU6IHJvdy50eXBlLCBwYXlsb2FkOiByb3cucGF5bG9hZCA/PyB7fSwgY3JlYXRlZF9hdCwgcmVhZF9hdDogbnVsbCB9O1xyXG4gIGNvbnN0IGFyciA9IHMubm90aWZpY2F0aW9uc0J5VXNlci5nZXQocm93LnVzZXJfaWQpID8/IFtdO1xyXG4gIGFyci51bnNoaWZ0KG9iaik7XHJcbiAgcy5ub3RpZmljYXRpb25zQnlVc2VyLnNldChyb3cudXNlcl9pZCwgYXJyKTtcclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGlzdFRlc3ROb3RpZmljYXRpb25zQnlVc2VyKHVzZXJJZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBpZiAoIXMubm90aWZpY2F0aW9uc0J5VXNlcikgcy5ub3RpZmljYXRpb25zQnlVc2VyID0gbmV3IE1hcDxzdHJpbmcsIGFueVtdPigpO1xyXG4gIHJldHVybiAocy5ub3RpZmljYXRpb25zQnlVc2VyLmdldCh1c2VySWQpID8/IFtdKS5zbGljZSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFya1Rlc3ROb3RpZmljYXRpb25SZWFkKGlkOiBzdHJpbmcpIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIGlmICghcy5ub3RpZmljYXRpb25zQnlVc2VyKSBzLm5vdGlmaWNhdGlvbnNCeVVzZXIgPSBuZXcgTWFwPHN0cmluZywgYW55W10+KCk7XHJcbiAgZm9yIChjb25zdCBbdWlkLCBhcnJdIG9mIHMubm90aWZpY2F0aW9uc0J5VXNlci5lbnRyaWVzKCkpIHtcclxuICAgIGNvbnN0IGlkeCA9IGFyci5maW5kSW5kZXgoKG46IGFueSkgPT4gbi5pZCA9PT0gaWQpO1xyXG4gICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgIGFycltpZHhdID0geyAuLi5hcnJbaWR4XSwgcmVhZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH07XHJcbiAgICAgIHMubm90aWZpY2F0aW9uc0J5VXNlci5zZXQodWlkLCBhcnIpO1xyXG4gICAgICByZXR1cm4gYXJyW2lkeF07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFya0FsbFRlc3ROb3RpZmljYXRpb25zUmVhZCh1c2VySWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgaWYgKCFzLm5vdGlmaWNhdGlvbnNCeVVzZXIpIHMubm90aWZpY2F0aW9uc0J5VXNlciA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKTtcclxuICBjb25zdCBhcnIgPSAocy5ub3RpZmljYXRpb25zQnlVc2VyLmdldCh1c2VySWQpID8/IFtdKS5tYXAoKG46IGFueSkgPT4gKHsgLi4ubiwgcmVhZF9hdDogbi5yZWFkX2F0ID8/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KSk7XHJcbiAgcy5ub3RpZmljYXRpb25zQnlVc2VyLnNldCh1c2VySWQsIGFycik7XHJcbiAgcmV0dXJuIHsgb2s6IHRydWUgfSBhcyBjb25zdDtcclxufVxyXG5cclxuLy8gPT09PT0gTm90aWZpY2F0aW9uIHByZWZlcmVuY2VzICh0ZXN0LW1vZGUpID09PT09XHJcbnR5cGUgVGVzdE5vdGlmaWNhdGlvblByZWZzID0geyBbdHlwZTogc3RyaW5nXTogYm9vbGVhbiB9O1xyXG5jb25zdCBERUZBVUxUX1BSRUZTOiBUZXN0Tm90aWZpY2F0aW9uUHJlZnMgPSB7XHJcbiAgJ2Fzc2lnbm1lbnQ6bmV3JzogdHJ1ZSxcclxuICAnc3VibWlzc2lvbjpncmFkZWQnOiB0cnVlLFxyXG4gICdtZXNzYWdlOm5ldyc6IHRydWUsXHJcbiAgJ2Fubm91bmNlbWVudDpwdWJsaXNoZWQnOiB0cnVlLFxyXG4gICdxdWl6OmR1ZS1zb29uJzogdHJ1ZVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRlc3ROb3RpZmljYXRpb25QcmVmZXJlbmNlcyh1c2VySWQ6IHN0cmluZyk6IFRlc3ROb3RpZmljYXRpb25QcmVmcyB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBpZiAoIXMubm90aWZpY2F0aW9uUHJlZnNCeVVzZXIpIHMubm90aWZpY2F0aW9uUHJlZnNCeVVzZXIgPSBuZXcgTWFwPHN0cmluZywgVGVzdE5vdGlmaWNhdGlvblByZWZzPigpO1xyXG4gIGNvbnN0IGN1cnJlbnQgPSBzLm5vdGlmaWNhdGlvblByZWZzQnlVc2VyLmdldCh1c2VySWQpO1xyXG4gIGlmIChjdXJyZW50KSByZXR1cm4geyAuLi5ERUZBVUxUX1BSRUZTLCAuLi5jdXJyZW50IH07XHJcbiAgcmV0dXJuIHsgLi4uREVGQVVMVF9QUkVGUyB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VGVzdE5vdGlmaWNhdGlvblByZWZlcmVuY2VzKHVzZXJJZDogc3RyaW5nLCBwYXJ0aWFsOiBUZXN0Tm90aWZpY2F0aW9uUHJlZnMpIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIGlmICghcy5ub3RpZmljYXRpb25QcmVmc0J5VXNlcikgcy5ub3RpZmljYXRpb25QcmVmc0J5VXNlciA9IG5ldyBNYXA8c3RyaW5nLCBUZXN0Tm90aWZpY2F0aW9uUHJlZnM+KCk7XHJcbiAgY29uc3QgbWVyZ2VkID0geyAuLi5nZXRUZXN0Tm90aWZpY2F0aW9uUHJlZmVyZW5jZXModXNlcklkKSwgLi4ucGFydGlhbCB9IGFzIFRlc3ROb3RpZmljYXRpb25QcmVmcztcclxuICBzLm5vdGlmaWNhdGlvblByZWZzQnlVc2VyLnNldCh1c2VySWQsIG1lcmdlZCk7XHJcbiAgcmV0dXJuIG1lcmdlZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZERlbGl2ZXJUZXN0Tm90aWZpY2F0aW9uKHVzZXJJZDogc3RyaW5nLCB0eXBlOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICBjb25zdCBwcmVmcyA9IGdldFRlc3ROb3RpZmljYXRpb25QcmVmZXJlbmNlcyh1c2VySWQpO1xyXG4gIGNvbnN0IHZhbCA9IHByZWZzW3R5cGVdO1xyXG4gIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIXZhbDtcclxufVxyXG5cclxuLy8gQXNzaWdubWVudHMgaGVscGVyc1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkVGVzdEFzc2lnbm1lbnQocm93OiBUZXN0QXNzaWdubWVudCkge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgY29uc3QgYXJyID0gcy5hc3NpZ25tZW50c0J5Q291cnNlLmdldChyb3cuY291cnNlX2lkKSA/PyBbXTtcclxuICBhcnIucHVzaChyb3cpO1xyXG4gIGFyci5zb3J0KChhOiBUZXN0QXNzaWdubWVudCwgYjogVGVzdEFzc2lnbm1lbnQpID0+IG5ldyBEYXRlKGIuY3JlYXRlZF9hdCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5jcmVhdGVkX2F0KS5nZXRUaW1lKCkpO1xyXG4gIHMuYXNzaWdubWVudHNCeUNvdXJzZS5zZXQocm93LmNvdXJzZV9pZCwgYXJyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RUZXN0QXNzaWdubWVudHNCeUNvdXJzZShjb3Vyc2VJZDogc3RyaW5nKTogVGVzdEFzc2lnbm1lbnRbXSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICByZXR1cm4gcy5hc3NpZ25tZW50c0J5Q291cnNlLmdldChjb3Vyc2VJZCkgPz8gW107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUZXN0QXNzaWdubWVudChpZDogc3RyaW5nLCBkYXRhOiBQYXJ0aWFsPE9taXQ8VGVzdEFzc2lnbm1lbnQsICdpZCcgfCAnY291cnNlX2lkJyB8ICdjcmVhdGVkX2F0Jz4+KSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBmb3IgKGNvbnN0IFtjb3Vyc2VJZCwgYXJyXSBvZiBzLmFzc2lnbm1lbnRzQnlDb3Vyc2UuZW50cmllcygpKSB7XHJcbiAgICBjb25zdCBpZHggPSBhcnIuZmluZEluZGV4KCh4OiBUZXN0QXNzaWdubWVudCkgPT4geC5pZCA9PT0gaWQpO1xyXG4gICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSB7IC4uLmFycltpZHhdLCAuLi5kYXRhIH0gYXMgVGVzdEFzc2lnbm1lbnQ7XHJcbiAgICAgIGFycltpZHhdID0gbmV4dDtcclxuICAgICAgcy5hc3NpZ25tZW50c0J5Q291cnNlLnNldChjb3Vyc2VJZCwgYXJyKTtcclxuICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlVGVzdEFzc2lnbm1lbnQoaWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgZm9yIChjb25zdCBbY291cnNlSWQsIGFycl0gb2Ygcy5hc3NpZ25tZW50c0J5Q291cnNlLmVudHJpZXMoKSkge1xyXG4gICAgY29uc3QgbmV4dCA9IGFyci5maWx0ZXIoKHg6IFRlc3RBc3NpZ25tZW50KSA9PiB4LmlkICE9PSBpZCk7XHJcbiAgICBzLmFzc2lnbm1lbnRzQnlDb3Vyc2Uuc2V0KGNvdXJzZUlkLCBuZXh0KTtcclxuICB9XHJcbiAgcmV0dXJuIHsgb2s6IHRydWUgfSBhcyBjb25zdDtcclxufVxyXG5cclxuLy8gPT09PT0gRmlsZXMgKHRlc3QtbW9kZSkgPT09PT1cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZFRlc3RGaWxlKGlucHV0OiB7IG93bmVyX3R5cGU6IHN0cmluZzsgb3duZXJfaWQ6IHN0cmluZzsgY29udGVudF90eXBlOiBzdHJpbmc7IGRhdGFfYmFzZTY0OiBzdHJpbmcgfSkge1xyXG4gIGNvbnN0IGlkID0gbWFrZUlkKCdmJyk7XHJcbiAgY29uc3Qgcm93ID0geyBpZCwgb3duZXJfdHlwZTogaW5wdXQub3duZXJfdHlwZSwgb3duZXJfaWQ6IGlucHV0Lm93bmVyX2lkLCBjb250ZW50X3R5cGU6IGlucHV0LmNvbnRlbnRfdHlwZSwgZGF0YV9iYXNlNjQ6IGlucHV0LmRhdGFfYmFzZTY0LCBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfTtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIHMuZmlsZXNCeUlkLnNldChpZCwgcm93KTtcclxuICByZXR1cm4gcm93O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVzdEZpbGUoaWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgcmV0dXJuIHMuZmlsZXNCeUlkLmdldChpZCkgPz8gbnVsbDtcclxufVxyXG5cclxuLy8gU3VibWlzc2lvbnMgaGVscGVyc1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkVGVzdFN1Ym1pc3Npb24ocm93OiBUZXN0U3VibWlzc2lvbikge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgY29uc3QgYXJyID0gcy5zdWJtaXNzaW9uc0J5QXNzaWdubWVudC5nZXQocm93LmFzc2lnbm1lbnRfaWQpID8/IFtdO1xyXG4gIGFyci51bnNoaWZ0KHJvdyk7XHJcbiAgcy5zdWJtaXNzaW9uc0J5QXNzaWdubWVudC5zZXQocm93LmFzc2lnbm1lbnRfaWQsIGFycik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0VGVzdFN1Ym1pc3Npb25zQnlBc3NpZ25tZW50KGFzc2lnbm1lbnRJZDogc3RyaW5nKTogVGVzdFN1Ym1pc3Npb25bXSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICByZXR1cm4gcy5zdWJtaXNzaW9uc0J5QXNzaWdubWVudC5nZXQoYXNzaWdubWVudElkKSA/PyBbXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdyYWRlVGVzdFN1Ym1pc3Npb24oaWQ6IHN0cmluZywgZGF0YTogeyBzY29yZTogbnVtYmVyOyBmZWVkYmFjaz86IHN0cmluZyB9KSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBmb3IgKGNvbnN0IFthaWQsIGFycl0gb2Ygcy5zdWJtaXNzaW9uc0J5QXNzaWdubWVudC5lbnRyaWVzKCkpIHtcclxuICAgIGNvbnN0IGlkeCA9IGFyci5maW5kSW5kZXgoKHg6IFRlc3RTdWJtaXNzaW9uKSA9PiB4LmlkID09PSBpZCk7XHJcbiAgICBpZiAoaWR4ID49IDApIHtcclxuICAgICAgY29uc3QgbmV4dCA9IHsgLi4uYXJyW2lkeF0sIHNjb3JlOiBkYXRhLnNjb3JlLCBmZWVkYmFjazogZGF0YS5mZWVkYmFjayA/PyBudWxsIH0gYXMgVGVzdFN1Ym1pc3Npb247XHJcbiAgICAgIGFycltpZHhdID0gbmV4dDtcclxuICAgICAgcy5zdWJtaXNzaW9uc0J5QXNzaWdubWVudC5zZXQoYWlkLCBhcnIpO1xyXG4gICAgICByZXR1cm4gbmV4dDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8vID09PT09IFF1aXp6ZXMgaGVscGVycyAodGVzdC1tb2RlKSA9PT09PVxyXG50eXBlIFRlc3RRdWl6ID0geyBpZDogc3RyaW5nOyBjb3Vyc2VfaWQ6IHN0cmluZzsgdGl0bGU6IHN0cmluZzsgdGltZV9saW1pdF9zZWM/OiBudW1iZXIgfCBudWxsOyBwb2ludHM6IG51bWJlcjsgY3JlYXRlZF9hdDogc3RyaW5nIH07XHJcbnR5cGUgVGVzdFF1aXpRdWVzdGlvbiA9IHsgaWQ6IHN0cmluZzsgcXVpel9pZDogc3RyaW5nOyB0ZXh0OiBzdHJpbmc7IG9yZGVyX2luZGV4OiBudW1iZXIgfTtcclxudHlwZSBUZXN0UXVpekNob2ljZSA9IHsgaWQ6IHN0cmluZzsgcXVlc3Rpb25faWQ6IHN0cmluZzsgdGV4dDogc3RyaW5nOyBjb3JyZWN0OiBib29sZWFuOyBvcmRlcl9pbmRleDogbnVtYmVyIH07XHJcbnR5cGUgVGVzdFF1aXpBdHRlbXB0ID0geyBpZDogc3RyaW5nOyBxdWl6X2lkOiBzdHJpbmc7IHN0dWRlbnRfaWQ6IHN0cmluZzsgc3RhcnRlZF9hdDogc3RyaW5nOyBzdWJtaXR0ZWRfYXQ/OiBzdHJpbmcgfCBudWxsOyBzY29yZTogbnVtYmVyIH07XHJcbnR5cGUgVGVzdFF1aXpBbnN3ZXIgPSB7IGlkOiBzdHJpbmc7IGF0dGVtcHRfaWQ6IHN0cmluZzsgcXVlc3Rpb25faWQ6IHN0cmluZzsgY2hvaWNlX2lkOiBzdHJpbmc7IGNyZWF0ZWRfYXQ6IHN0cmluZyB9O1xyXG5cclxuZnVuY3Rpb24gbWFrZUlkKF9wcmVmaXg6IHN0cmluZykge1xyXG4gIGNvbnN0IGhleCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcclxuICBjb25zdCByYW5kID0gKG46IG51bWJlcikgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9LCAoKSA9PiBoZXhbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaGV4Lmxlbmd0aCldKS5qb2luKCcnKTtcclxuICBjb25zdCBzMSA9IHJhbmQoOCk7XHJcbiAgY29uc3QgczIgPSByYW5kKDQpO1xyXG4gIGNvbnN0IHMzID0gcmFuZCg0KTtcclxuICBjb25zdCBzNCA9IHJhbmQoNCk7XHJcbiAgY29uc3QgczUgPSByYW5kKDEyKTtcclxuICByZXR1cm4gYCR7czF9LSR7czJ9LSR7czN9LSR7czR9LSR7czV9YDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZFF1aXooaW5wdXQ6IHsgY291cnNlX2lkOiBzdHJpbmc7IHRpdGxlOiBzdHJpbmc7IHRpbWVfbGltaXRfc2VjPzogbnVtYmVyOyBwb2ludHM/OiBudW1iZXIgfSk6IFRlc3RRdWl6IHtcclxuICBjb25zdCByb3c6IFRlc3RRdWl6ID0ge1xyXG4gICAgaWQ6IG1ha2VJZCgncScpLFxyXG4gICAgY291cnNlX2lkOiBpbnB1dC5jb3Vyc2VfaWQsXHJcbiAgICB0aXRsZTogaW5wdXQudGl0bGUsXHJcbiAgICB0aW1lX2xpbWl0X3NlYzogaW5wdXQudGltZV9saW1pdF9zZWMgPz8gbnVsbCxcclxuICAgIHBvaW50czogaW5wdXQucG9pbnRzID8/IDEwMCxcclxuICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gIH07XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBjb25zdCBhcnIgPSBzLnF1aXp6ZXNCeUNvdXJzZS5nZXQocm93LmNvdXJzZV9pZCkgPz8gW107XHJcbiAgYXJyLnVuc2hpZnQocm93KTtcclxuICBzLnF1aXp6ZXNCeUNvdXJzZS5zZXQocm93LmNvdXJzZV9pZCwgYXJyKTtcclxuICByZXR1cm4gcm93O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGlzdFF1aXp6ZXNCeUNvdXJzZShjb3Vyc2VJZDogc3RyaW5nKTogVGVzdFF1aXpbXSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICByZXR1cm4gKHMucXVpenplc0J5Q291cnNlLmdldChjb3Vyc2VJZCkgPz8gW10pLnNsaWNlKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVRdWl6KGlkOiBzdHJpbmcsIGRhdGE6IHsgdGl0bGU/OiBzdHJpbmc7IHRpbWVfbGltaXRfc2VjPzogbnVtYmVyOyBwb2ludHM/OiBudW1iZXIgfSkge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgZm9yIChjb25zdCBbY291cnNlSWQsIGFycl0gb2Ygcy5xdWl6emVzQnlDb3Vyc2UuZW50cmllcygpKSB7XHJcbiAgICBjb25zdCBpZHggPSBhcnIuZmluZEluZGV4KChxOiBUZXN0UXVpeikgPT4gcS5pZCA9PT0gaWQpO1xyXG4gICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgIGNvbnN0IHEgPSBhcnJbaWR4XTtcclxuICAgICAgY29uc3QgdXBkYXRlZCA9IHsgLi4ucSwgLi4uZGF0YSB9IGFzIFRlc3RRdWl6O1xyXG4gICAgICBhcnJbaWR4XSA9IHVwZGF0ZWQ7XHJcbiAgICAgIHMucXVpenplc0J5Q291cnNlLnNldChjb3Vyc2VJZCwgYXJyKTtcclxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlUXVpeihpZDogc3RyaW5nKSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBmb3IgKGNvbnN0IFtjb3Vyc2VJZCwgYXJyXSBvZiBzLnF1aXp6ZXNCeUNvdXJzZS5lbnRyaWVzKCkpIHtcclxuICAgIGNvbnN0IG5leHQgPSAoYXJyIGFzIFRlc3RRdWl6W10pLmZpbHRlcihxID0+IHEuaWQgIT09IGlkKTtcclxuICAgIGlmIChuZXh0Lmxlbmd0aCAhPT0gYXJyLmxlbmd0aCkge1xyXG4gICAgICBzLnF1aXp6ZXNCeUNvdXJzZS5zZXQoY291cnNlSWQsIG5leHQpO1xyXG4gICAgICAvLyBDYXNjYWRlOiByZW1vdmUgcXVlc3Rpb25zIGZvciB0aGlzIHF1aXpcclxuICAgICAgcy5xdWVzdGlvbnNCeVF1aXouZGVsZXRlKGlkKTtcclxuICAgICAgcmV0dXJuIHsgb2s6IHRydWUgfSBhcyBjb25zdDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHsgb2s6IGZhbHNlIH0gYXMgY29uc3Q7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRRdWVzdGlvbihpbnB1dDogeyBxdWl6X2lkOiBzdHJpbmc7IHRleHQ6IHN0cmluZzsgb3JkZXJfaW5kZXg/OiBudW1iZXIgfSk6IFRlc3RRdWl6UXVlc3Rpb24ge1xyXG4gIGNvbnN0IHJvdzogVGVzdFF1aXpRdWVzdGlvbiA9IHsgaWQ6IG1ha2VJZCgncicpLCBxdWl6X2lkOiBpbnB1dC5xdWl6X2lkLCB0ZXh0OiBpbnB1dC50ZXh0LCBvcmRlcl9pbmRleDogaW5wdXQub3JkZXJfaW5kZXggPz8gMSB9O1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgY29uc3QgYXJyID0gcy5xdWVzdGlvbnNCeVF1aXouZ2V0KHJvdy5xdWl6X2lkKSA/PyBbXTtcclxuICBhcnIucHVzaChyb3cpO1xyXG4gIGFyci5zb3J0KChhOiBUZXN0UXVpelF1ZXN0aW9uLCBiOiBUZXN0UXVpelF1ZXN0aW9uKSA9PiBhLm9yZGVyX2luZGV4IC0gYi5vcmRlcl9pbmRleCk7XHJcbiAgcy5xdWVzdGlvbnNCeVF1aXouc2V0KHJvdy5xdWl6X2lkLCBhcnIpO1xyXG4gIHJldHVybiByb3c7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsaXN0UXVlc3Rpb25zQnlRdWl6KHF1aXpJZDogc3RyaW5nKTogVGVzdFF1aXpRdWVzdGlvbltdIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIHJldHVybiAocy5xdWVzdGlvbnNCeVF1aXouZ2V0KHF1aXpJZCkgPz8gW10pLnNsaWNlKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRDaG9pY2UoaW5wdXQ6IHsgcXVlc3Rpb25faWQ6IHN0cmluZzsgdGV4dDogc3RyaW5nOyBjb3JyZWN0OiBib29sZWFuOyBvcmRlcl9pbmRleD86IG51bWJlciB9KTogVGVzdFF1aXpDaG9pY2Uge1xyXG4gIGNvbnN0IHJvdzogVGVzdFF1aXpDaG9pY2UgPSB7IGlkOiBtYWtlSWQoJ3MnKSwgcXVlc3Rpb25faWQ6IGlucHV0LnF1ZXN0aW9uX2lkLCB0ZXh0OiBpbnB1dC50ZXh0LCBjb3JyZWN0OiBpbnB1dC5jb3JyZWN0LCBvcmRlcl9pbmRleDogaW5wdXQub3JkZXJfaW5kZXggPz8gMSB9O1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgY29uc3QgYXJyID0gcy5jaG9pY2VzQnlRdWVzdGlvbi5nZXQocm93LnF1ZXN0aW9uX2lkKSA/PyBbXTtcclxuICBhcnIucHVzaChyb3cpO1xyXG4gIGFyci5zb3J0KChhOiBUZXN0UXVpekNob2ljZSwgYjogVGVzdFF1aXpDaG9pY2UpID0+IGEub3JkZXJfaW5kZXggLSBiLm9yZGVyX2luZGV4KTtcclxuICBzLmNob2ljZXNCeVF1ZXN0aW9uLnNldChyb3cucXVlc3Rpb25faWQsIGFycik7XHJcbiAgcmV0dXJuIHJvdztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RDaG9pY2VzQnlRdWVzdGlvbihxdWVzdGlvbklkOiBzdHJpbmcpOiBUZXN0UXVpekNob2ljZVtdIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIHJldHVybiAocy5jaG9pY2VzQnlRdWVzdGlvbi5nZXQocXVlc3Rpb25JZCkgPz8gW10pLnNsaWNlKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdGFydEF0dGVtcHQoaW5wdXQ6IHsgcXVpel9pZDogc3RyaW5nOyBzdHVkZW50X2lkOiBzdHJpbmcgfSk6IFRlc3RRdWl6QXR0ZW1wdCB7XHJcbiAgY29uc3Qgcm93OiBUZXN0UXVpekF0dGVtcHQgPSB7IGlkOiBtYWtlSWQoJ3QnKSwgcXVpel9pZDogaW5wdXQucXVpel9pZCwgc3R1ZGVudF9pZDogaW5wdXQuc3R1ZGVudF9pZCwgc3RhcnRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCBzdWJtaXR0ZWRfYXQ6IG51bGwsIHNjb3JlOiAwIH07XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICBjb25zdCBhcnIgPSBzLmF0dGVtcHRzQnlRdWl6LmdldChyb3cucXVpel9pZCkgPz8gW107XHJcbiAgYXJyLnB1c2gocm93KTtcclxuICBzLmF0dGVtcHRzQnlRdWl6LnNldChyb3cucXVpel9pZCwgYXJyKTtcclxuICByZXR1cm4gcm93O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXBzZXJ0QW5zd2VyKGlucHV0OiB7IGF0dGVtcHRfaWQ6IHN0cmluZzsgcXVlc3Rpb25faWQ6IHN0cmluZzsgY2hvaWNlX2lkOiBzdHJpbmcgfSk6IFRlc3RRdWl6QW5zd2VyIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIGNvbnN0IGFuc0FyciA9IHMuYW5zd2Vyc0J5QXR0ZW1wdC5nZXQoaW5wdXQuYXR0ZW1wdF9pZCkgPz8gW107XHJcbiAgY29uc3QgaWR4ID0gYW5zQXJyLmZpbmRJbmRleCgoYTogVGVzdFF1aXpBbnN3ZXIpID0+IGEucXVlc3Rpb25faWQgPT09IGlucHV0LnF1ZXN0aW9uX2lkKTtcclxuICBjb25zdCByb3c6IFRlc3RRdWl6QW5zd2VyID0gaWR4ID49IDAgPyB7IC4uLmFuc0FycltpZHhdLCBjaG9pY2VfaWQ6IGlucHV0LmNob2ljZV9pZCwgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0gOiB7XHJcbiAgICBpZDogbWFrZUlkKCd1JyksIGF0dGVtcHRfaWQ6IGlucHV0LmF0dGVtcHRfaWQsIHF1ZXN0aW9uX2lkOiBpbnB1dC5xdWVzdGlvbl9pZCwgY2hvaWNlX2lkOiBpbnB1dC5jaG9pY2VfaWQsIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gIH07XHJcbiAgaWYgKGlkeCA+PSAwKSBhbnNBcnJbaWR4XSA9IHJvdzsgZWxzZSBhbnNBcnIucHVzaChyb3cpO1xyXG4gIHMuYW5zd2Vyc0J5QXR0ZW1wdC5zZXQoaW5wdXQuYXR0ZW1wdF9pZCwgYW5zQXJyKTtcclxuICByZXR1cm4gcm93O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3VibWl0QXR0ZW1wdChpbnB1dDogeyBhdHRlbXB0X2lkOiBzdHJpbmcgfSk6IFRlc3RRdWl6QXR0ZW1wdCB8IG51bGwge1xyXG4gIGNvbnN0IHMgPSBzdGF0ZSBhcyBhbnk7XHJcbiAgbGV0IGF0dGVtcHQ6IFRlc3RRdWl6QXR0ZW1wdCB8IHVuZGVmaW5lZDtcclxuICBsZXQgcXVpeklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgZm9yIChjb25zdCBbcWlkLCBhcnJdIG9mIHMuYXR0ZW1wdHNCeVF1aXouZW50cmllcygpKSB7XHJcbiAgICBjb25zdCBmb3VuZCA9IChhcnIgYXMgVGVzdFF1aXpBdHRlbXB0W10pLmZpbmQoYSA9PiBhLmlkID09PSBpbnB1dC5hdHRlbXB0X2lkKTtcclxuICAgIGlmIChmb3VuZCkgeyBhdHRlbXB0ID0gZm91bmQ7IHF1aXpJZCA9IHFpZDsgYnJlYWs7IH1cclxuICB9XHJcbiAgaWYgKCFhdHRlbXB0IHx8ICFxdWl6SWQpIHJldHVybiBudWxsO1xyXG4gIGNvbnN0IHF1ZXN0aW9uczogVGVzdFF1aXpRdWVzdGlvbltdID0gcy5xdWVzdGlvbnNCeVF1aXouZ2V0KHF1aXpJZCkgPz8gW107XHJcbiAgY29uc3QgdG90YWwgPSBxdWVzdGlvbnMubGVuZ3RoO1xyXG4gIGNvbnN0IGFuc3dlcnM6IFRlc3RRdWl6QW5zd2VyW10gPSBzLmFuc3dlcnNCeUF0dGVtcHQuZ2V0KGF0dGVtcHQuaWQpID8/IFtdO1xyXG4gIGxldCBjb3JyZWN0ID0gMDtcclxuICBmb3IgKGNvbnN0IHEgb2YgcXVlc3Rpb25zKSB7XHJcbiAgICBjb25zdCBhID0gYW5zd2Vycy5maW5kKHggPT4geC5xdWVzdGlvbl9pZCA9PT0gcS5pZCk7XHJcbiAgICBpZiAoIWEpIGNvbnRpbnVlO1xyXG4gICAgY29uc3QgY2hvaWNlczogVGVzdFF1aXpDaG9pY2VbXSA9IHMuY2hvaWNlc0J5UXVlc3Rpb24uZ2V0KHEuaWQpID8/IFtdO1xyXG4gICAgY29uc3QgY29ycmVjdENob2ljZSA9IGNob2ljZXMuZmluZChjID0+IGMuY29ycmVjdCk7XHJcbiAgICBpZiAoY29ycmVjdENob2ljZSAmJiBhLmNob2ljZV9pZCA9PT0gY29ycmVjdENob2ljZS5pZCkgY29ycmVjdCsrO1xyXG4gIH1cclxuICBsZXQgcXVpelBvaW50cyA9IDEwMDtcclxuICBmb3IgKGNvbnN0IFssIHF1aXp6ZXNdIG9mIHMucXVpenplc0J5Q291cnNlLmVudHJpZXMoKSkge1xyXG4gICAgY29uc3QgbWF0Y2ggPSAocXVpenplcyBhcyBUZXN0UXVpeltdKS5maW5kKChxOiBUZXN0UXVpeikgPT4gcS5pZCA9PT0gcXVpeklkKTtcclxuICAgIGlmIChtYXRjaCkgeyBxdWl6UG9pbnRzID0gbWF0Y2gucG9pbnRzOyBicmVhazsgfVxyXG4gIH1cclxuICBjb25zdCBzY29yZSA9IHRvdGFsID4gMCA/IE1hdGgucm91bmQoKGNvcnJlY3QgLyB0b3RhbCkgKiBxdWl6UG9pbnRzKSA6IDA7XHJcbiAgYXR0ZW1wdC5zdWJtaXR0ZWRfYXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgYXR0ZW1wdC5zY29yZSA9IHNjb3JlO1xyXG4gIHJldHVybiBhdHRlbXB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbGlzdEF0dGVtcHRzRm9yUXVpeihxdWl6X2lkOiBzdHJpbmcpOiBUZXN0UXVpekF0dGVtcHRbXSB7XHJcbiAgY29uc3QgcyA9IHN0YXRlIGFzIGFueTtcclxuICByZXR1cm4gKHMuYXR0ZW1wdHNCeVF1aXouZ2V0KHF1aXpfaWQpID8/IFtdKS5zbGljZSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0ZW1wdEZvclN0dWRlbnQocXVpel9pZDogc3RyaW5nLCBzdHVkZW50X2lkOiBzdHJpbmcpOiBUZXN0UXVpekF0dGVtcHQgfCBudWxsIHtcclxuICBjb25zdCBzID0gc3RhdGUgYXMgYW55O1xyXG4gIGNvbnN0IGFycjogVGVzdFF1aXpBdHRlbXB0W10gPSBzLmF0dGVtcHRzQnlRdWl6LmdldChxdWl6X2lkKSA/PyBbXTtcclxuICBjb25zdCBtaW5lID0gYXJyLmZpbHRlcihhID0+IGEuc3R1ZGVudF9pZCA9PT0gc3R1ZGVudF9pZCk7XHJcbiAgaWYgKG1pbmUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuICBtaW5lLnNvcnQoKGEsIGIpID0+IGIuc3RhcnRlZF9hdC5sb2NhbGVDb21wYXJlKGEuc3RhcnRlZF9hdCkpO1xyXG4gIHJldHVybiBtaW5lWzBdO1xyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiZ2xvYmFsU3RvcmUiLCJnbG9iYWxUaGlzIiwic3RhdGUiLCJfX1RFU1RfU1RPUkVfXyIsImNvdXJzZXMiLCJNYXAiLCJsZXNzb25zQnlDb3Vyc2UiLCJtb2R1bGVzQnlDb3Vyc2UiLCJlbnJvbGxtZW50c0J5U3R1ZGVudCIsImVucm9sbG1lbnRzQnlDb3Vyc2UiLCJwcm9maWxlc0J5SWQiLCJwYXJlbnRMaW5rc0J5UGFyZW50IiwiYW55U3RhdGUiLCJhc3NpZ25tZW50c0J5Q291cnNlIiwic3VibWlzc2lvbnNCeUFzc2lnbm1lbnQiLCJxdWl6emVzQnlDb3Vyc2UiLCJxdWVzdGlvbnNCeVF1aXoiLCJjaG9pY2VzQnlRdWVzdGlvbiIsImF0dGVtcHRzQnlRdWl6IiwiYW5zd2Vyc0J5QXR0ZW1wdCIsImFubm91bmNlbWVudHNCeUNvdXJzZSIsImZpbGVzQnlJZCIsIm1lc3NhZ2VUaHJlYWRzIiwicGFydGljaXBhbnRzQnlUaHJlYWQiLCJtZXNzYWdlc0J5VGhyZWFkIiwicmVhZEJ5TWVzc2FnZSIsImZlYXR1cmVGbGFncyIsImFkZFRlc3RDb3Vyc2UiLCJjb3Vyc2UiLCJzZXQiLCJpZCIsImdldFRlc3RDb3Vyc2UiLCJjb3Vyc2VJZCIsImdldCIsImxpc3RUZXN0Q291cnNlc0J5VGVhY2hlciIsInRlYWNoZXJJZCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImZpbHRlciIsImMiLCJ0ZWFjaGVyX2lkIiwiYWRkVGVzdExlc3NvbiIsImxlc3NvbiIsImFyciIsImNvdXJzZV9pZCIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJvcmRlcl9pbmRleCIsImxpc3RUZXN0TGVzc29uc0J5Q291cnNlIiwicmVzZXRUZXN0U3RvcmUiLCJjbGVhciIsImRlbGV0ZVRlc3RDb3Vyc2UiLCJkZWxldGUiLCJyZW9yZGVyVGVzdExlc3NvbnMiLCJ1cGRhdGVzIiwiYnlJZCIsIm1hcCIsImwiLCJ1Iiwicm93IiwiYWRkVGVzdE1vZHVsZSIsImxpc3RUZXN0TW9kdWxlc0J5Q291cnNlIiwidXBkYXRlVGVzdE1vZHVsZSIsImRhdGEiLCJlbnRyaWVzIiwiaWR4IiwiZmluZEluZGV4IiwibSIsInVwZGF0ZWQiLCJ1bmRlZmluZWQiLCJkZWxldGVUZXN0TW9kdWxlIiwiZmlsdGVyZWQiLCJsZW5ndGgiLCJhZGRUZXN0RW5yb2xsbWVudCIsInN0dWRlbnRfaWQiLCJsaXN0VGVzdEVucm9sbG1lbnRzQnlTdHVkZW50Iiwic3R1ZGVudElkIiwibGlzdFRlc3RFbnJvbGxtZW50c0J5Q291cnNlIiwidXBzZXJ0VGVzdFByb2ZpbGUiLCJwcm9maWxlIiwiZ2V0VGVzdFByb2ZpbGUiLCJhZGRUZXN0UGFyZW50TGluayIsInBhcmVudF9pZCIsImxpc3RUZXN0UGFyZW50Q2hpbGRyZW4iLCJwYXJlbnRJZCIsInJlbW92ZVRlc3RQYXJlbnRMaW5rIiwieCIsImxpc3RUZXN0UGFyZW50c0ZvclN0dWRlbnQiLCJyZXMiLCJwaWQiLCJzb21lIiwicGwiLCJhZGRUZXN0QW5ub3VuY2VtZW50IiwicyIsInVuc2hpZnQiLCJsaXN0VGVzdEFubm91bmNlbWVudHNCeUNvdXJzZSIsInNsaWNlIiwiZGVsZXRlVGVzdEFubm91bmNlbWVudCIsImNpZCIsIm5leHQiLCJvayIsImNyZWF0ZVRlc3RUaHJlYWQiLCJwYXJ0aWNpcGFudElkcyIsInJvbGVzIiwibWFrZUlkIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInBhcnRzIiwidWlkIiwidGhyZWFkX2lkIiwidXNlcl9pZCIsInJvbGUiLCJhZGRlZF9hdCIsImxpc3RUZXN0VGhyZWFkc0J5VXNlciIsInVzZXJJZCIsInQiLCJwIiwibG9jYWxlQ29tcGFyZSIsImFkZFRlc3RNZXNzYWdlIiwibXNnIiwic2VuZGVyX2lkIiwiYm9keSIsInJlYWRfYXQiLCJTZXQiLCJsaXN0VGVzdE1lc3NhZ2VzQnlUaHJlYWQiLCJ0aHJlYWRJZCIsIm1hcmtUZXN0TWVzc2FnZVJlYWRGb3JVc2VyIiwibWVzc2FnZUlkIiwiYWRkIiwidGlkIiwiY291bnRVbnJlYWRGb3JUaHJlYWQiLCJtc2dzIiwiY291bnQiLCJyZWFkU2V0IiwiaGFzIiwibWFya0FsbFRocmVhZE1lc3NhZ2VzUmVhZEZvclVzZXIiLCJsaXN0VGVzdEZlYXR1cmVGbGFncyIsIm9iaiIsImsiLCJ2Iiwic2V0VGVzdEZlYXR1cmVGbGFnIiwia2V5IiwidmFsdWUiLCJsaXN0VGVzdFBhcnRpY2lwYW50c0J5VGhyZWFkIiwiYWRkVGVzdE5vdGlmaWNhdGlvbiIsIm5vdGlmaWNhdGlvbnNCeVVzZXIiLCJ0eXBlIiwicGF5bG9hZCIsImxpc3RUZXN0Tm90aWZpY2F0aW9uc0J5VXNlciIsIm1hcmtUZXN0Tm90aWZpY2F0aW9uUmVhZCIsIm4iLCJtYXJrQWxsVGVzdE5vdGlmaWNhdGlvbnNSZWFkIiwiREVGQVVMVF9QUkVGUyIsImdldFRlc3ROb3RpZmljYXRpb25QcmVmZXJlbmNlcyIsIm5vdGlmaWNhdGlvblByZWZzQnlVc2VyIiwiY3VycmVudCIsInNldFRlc3ROb3RpZmljYXRpb25QcmVmZXJlbmNlcyIsInBhcnRpYWwiLCJtZXJnZWQiLCJzaG91bGREZWxpdmVyVGVzdE5vdGlmaWNhdGlvbiIsInByZWZzIiwidmFsIiwiYWRkVGVzdEFzc2lnbm1lbnQiLCJnZXRUaW1lIiwibGlzdFRlc3RBc3NpZ25tZW50c0J5Q291cnNlIiwidXBkYXRlVGVzdEFzc2lnbm1lbnQiLCJkZWxldGVUZXN0QXNzaWdubWVudCIsImFkZFRlc3RGaWxlIiwiaW5wdXQiLCJvd25lcl90eXBlIiwib3duZXJfaWQiLCJjb250ZW50X3R5cGUiLCJkYXRhX2Jhc2U2NCIsImdldFRlc3RGaWxlIiwiYWRkVGVzdFN1Ym1pc3Npb24iLCJhc3NpZ25tZW50X2lkIiwibGlzdFRlc3RTdWJtaXNzaW9uc0J5QXNzaWdubWVudCIsImFzc2lnbm1lbnRJZCIsImdyYWRlVGVzdFN1Ym1pc3Npb24iLCJhaWQiLCJzY29yZSIsImZlZWRiYWNrIiwiX3ByZWZpeCIsImhleCIsInJhbmQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJqb2luIiwiczEiLCJzMiIsInMzIiwiczQiLCJzNSIsImFkZFF1aXoiLCJ0aXRsZSIsInRpbWVfbGltaXRfc2VjIiwicG9pbnRzIiwibGlzdFF1aXp6ZXNCeUNvdXJzZSIsInVwZGF0ZVF1aXoiLCJxIiwiZGVsZXRlUXVpeiIsImFkZFF1ZXN0aW9uIiwicXVpel9pZCIsInRleHQiLCJsaXN0UXVlc3Rpb25zQnlRdWl6IiwicXVpeklkIiwiYWRkQ2hvaWNlIiwicXVlc3Rpb25faWQiLCJjb3JyZWN0IiwibGlzdENob2ljZXNCeVF1ZXN0aW9uIiwicXVlc3Rpb25JZCIsInN0YXJ0QXR0ZW1wdCIsInN0YXJ0ZWRfYXQiLCJzdWJtaXR0ZWRfYXQiLCJ1cHNlcnRBbnN3ZXIiLCJhbnNBcnIiLCJhdHRlbXB0X2lkIiwiY2hvaWNlX2lkIiwic3VibWl0QXR0ZW1wdCIsImF0dGVtcHQiLCJxaWQiLCJmb3VuZCIsImZpbmQiLCJxdWVzdGlvbnMiLCJ0b3RhbCIsImFuc3dlcnMiLCJjaG9pY2VzIiwiY29ycmVjdENob2ljZSIsInF1aXpQb2ludHMiLCJxdWl6emVzIiwibWF0Y2giLCJyb3VuZCIsImxpc3RBdHRlbXB0c0ZvclF1aXoiLCJnZXRBdHRlbXB0Rm9yU3R1ZGVudCIsIm1pbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/testStore.ts\n"));

/***/ })

}]);